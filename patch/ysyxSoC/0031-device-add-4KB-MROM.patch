From 0c9b084b97a7f5eddaac88de70b5d7727b8c53eb Mon Sep 17 00:00:00 2001
From: Zihao Yu <yuzihao@ict.ac.cn>
Date: Fri, 1 Dec 2023 12:40:51 +0800
Subject: [PATCH 31/74] device: add 4KB MROM

---
 src/SoC.scala         |  3 +-
 src/device/MROM.scala | 71 +++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 73 insertions(+), 1 deletion(-)
 create mode 100644 src/device/MROM.scala

diff --git a/src/SoC.scala b/src/SoC.scala
index 3222485e..05063e16 100644
--- a/src/SoC.scala
+++ b/src/SoC.scala
@@ -35,9 +35,10 @@ class ysyxSoCASIC(implicit p: Parameters) extends LazyModule {
     AddressSet.misaligned(0x10001000, 0x1000) ++    // SPI controller
     AddressSet.misaligned(0x30000000, 0x10000000)   // XIP flash
   ))
+  val lmrom = LazyModule(new AXI4MROM(AddressSet.misaligned(0x20000000, 0x1000)))
 
   List(lspi.node, luart.node).map(_ := apbxbar)
-  List(chiplinkNode, apbxbar := AXI4ToAPB()).map(_ := xbar)
+  List(chiplinkNode, apbxbar := AXI4ToAPB(), lmrom.node).map(_ := xbar)
   xbar := cpu.masterNode
 
   override lazy val module = new Impl
diff --git a/src/device/MROM.scala b/src/device/MROM.scala
new file mode 100644
index 00000000..442e86e1
--- /dev/null
+++ b/src/device/MROM.scala
@@ -0,0 +1,71 @@
+package ysyx
+
+import chisel3._
+import chisel3.util._
+
+import freechips.rocketchip.amba.axi4._
+import org.chipsalliance.cde.config.Parameters
+import freechips.rocketchip.diplomacy._
+import freechips.rocketchip.util._
+
+class MROMHelper extends BlackBox with HasBlackBoxInline {
+  val io = IO(new Bundle {
+    val raddr = Input(UInt(32.W))
+    val ren = Input(Bool())
+    val rdata = Output(UInt(32.W))
+  })
+  setInline("MROMHelper.v",
+    """module MROMHelper(
+      |  input [31:0] raddr,
+      |  input ren,
+      |  output reg [31:0] rdata
+      |);
+      |import "DPI-C" function void mrom_read(input int raddr, output int rdata);
+      |always @(*) begin
+      |  if (ren) mrom_read(raddr, rdata);
+      |  else rdata = 0;
+      |end
+      |endmodule
+    """.stripMargin)
+}
+
+class AXI4MROM(address: Seq[AddressSet])(implicit p: Parameters) extends LazyModule {
+  val beatBytes = 8
+  val node = AXI4SlaveNode(Seq(AXI4SlavePortParameters(
+    Seq(AXI4SlaveParameters(
+        address       = address,
+        executable    = true,
+        supportsWrite = TransferSizes.none,
+        supportsRead  = TransferSizes(1, beatBytes),
+        interleavedId = Some(0))
+    ),
+    beatBytes  = beatBytes)))
+
+  lazy val module = new Impl
+  class Impl extends LazyModuleImp(this) {
+    val (in, _) = node.in(0)
+
+    val mrom = Module(new MROMHelper)
+
+    val (stateIdle, stateWaitRready) = (0.U, 1.U)
+    val state = RegInit(stateIdle)
+    state := Mux(state === stateIdle,
+               Mux(in.ar.fire, stateWaitRready, stateIdle),
+               Mux(in. r.fire, stateIdle, stateWaitRready))
+
+    mrom.io.raddr := in.ar.bits.addr
+    mrom.io.ren := in.ar.fire
+    in.ar.ready := true.B
+    assert(!(in.ar.fire && in.ar.bits.size === 3.U)) // do not support 8 byte transfter
+
+    in.r.bits.data := RegEnable(Fill(2, mrom.io.rdata), in.ar.fire)
+    in.r.bits.id := RegEnable(in.ar.bits.id, in.ar.fire)
+    in.r.bits.resp := 0.U
+    in.r.bits.last := true.B
+    in.r.valid := (state === stateWaitRready)
+
+    in.aw.ready := false.B
+    in. w.ready := false.B
+    in. b.valid := false.B
+  }
+}
-- 
2.34.1

