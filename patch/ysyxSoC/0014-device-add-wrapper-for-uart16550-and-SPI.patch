From da7ec3ce1cb79eeb7b1c3fbd41e431e1d8975392 Mon Sep 17 00:00:00 2001
From: Zihao Yu <yuzihao@ict.ac.cn>
Date: Sun, 29 Aug 2021 09:29:10 +0800
Subject: [PATCH 14/74] device: add wrapper for uart16550 and SPI

---
 src/SoC.scala              | 27 ++++++---------------
 src/Top.scala              |  4 ++--
 src/device/SPI.scala       | 48 ++++++++++++++++++++++++++++++++++++++
 src/device/Uart16550.scala | 45 +++++++++++++++++++++++++++++++++++
 4 files changed, 102 insertions(+), 22 deletions(-)
 create mode 100644 src/device/SPI.scala
 create mode 100644 src/device/Uart16550.scala

diff --git a/src/SoC.scala b/src/SoC.scala
index ffe141ab..d9049fa0 100644
--- a/src/SoC.scala
+++ b/src/SoC.scala
@@ -23,18 +23,6 @@ object AXI4SlaveNodeGenerator {
       )).toSeq)
 }
 
-object APBSlaveNodeGenerator {
-  def apply(params: Option[MasterPortParams], base: BigInt, size: BigInt)(implicit valName: ValName) =
-    APBSlaveNode(params.map(p => APBSlavePortParameters(
-      slaves = Seq(APBSlaveParameters(
-        address    = AddressSet.misaligned(base, size),
-        executable = p.executable
-      )),
-      beatBytes = 4
-    )).toSeq)
-}
-
-// split cpu mem and mmio
 class ysyxSoCASIC(implicit p: Parameters) extends LazyModule {
   val idBits = 4
 
@@ -51,10 +39,10 @@ class ysyxSoCASIC(implicit p: Parameters) extends LazyModule {
   val chiplinkNode = AXI4SlaveNodeGenerator(p(ExtBus),
       ChipLinkParam.mmio.base, ChipLinkParam.mmio.mask + 1 + ChipLinkParam.mem.mask + 1)
 
-  val spiNode  = APBSlaveNodeGenerator(p(ExtBus), 0x10000000, 0x10001000)
-  val uartNode = APBSlaveNodeGenerator(p(ExtBus), 0x20001000, 0x1000)
+  val luart = LazyModule(new APBUart16550(AddressSet.misaligned(0x20001000, 0x1000)))
+  val lspi  = LazyModule(new APBSPI(AddressSet.misaligned(0x10000000, 0x10001000)))
 
-  List(spiNode, uartNode).map(_ := apbxbar)
+  List(lspi.node, luart.node).map(_ := apbxbar)
   List(chiplinkNode, apbxbar := AXI4ToAPB()).map(_ := xbar)
   xbar := cpuMasterNode
 
@@ -82,11 +70,10 @@ class ysyxSoCASIC(implicit p: Parameters) extends LazyModule {
     cpu_slave <> chiplink_dma
 
     // expose spi and uart slave interface as ports
-    val spi = IO(HeterogeneousBag.fromNode(spiNode.in))
-    val uart = IO(HeterogeneousBag.fromNode(uartNode.in))
-    List((spi, spiNode), (uart, uartNode)).map { case (io, node) =>
-      (io zip node.in) foreach { case (io, (bundle, _)) => io <> bundle }
-    }
+    val spi = IO(chiselTypeOf(lspi.module.spi_bundle))
+    val uart = IO(chiselTypeOf(luart.module.uart))
+    uart <> luart.module.uart
+    spi <> lspi.module.spi_bundle
   }
 }
 
diff --git a/src/Top.scala b/src/Top.scala
index eb156a67..6e1897f3 100644
--- a/src/Top.scala
+++ b/src/Top.scala
@@ -14,8 +14,8 @@ class ysyxSoCTop extends Module {
   mdut.dontTouchPorts()
   mdut.cpu_master := DontCare
   mdut.cpu_slave := DontCare
-  mdut.spi.foreach(_ := DontCare)
-  mdut.uart.foreach(_ := DontCare)
+  mdut.uart.rx := true.B
+  mdut.spi.miso := true.B
 }
 
 object Elaborate extends App {
diff --git a/src/device/SPI.scala b/src/device/SPI.scala
new file mode 100644
index 00000000..3e32fac5
--- /dev/null
+++ b/src/device/SPI.scala
@@ -0,0 +1,48 @@
+package ysyx
+
+import chisel3._
+import chisel3.util._
+
+import freechips.rocketchip.amba.apb._
+import org.chipsalliance.cde.config.Parameters
+import freechips.rocketchip.diplomacy._
+import freechips.rocketchip.util._
+
+class SPIIO(val csWidth: Int = 2) extends Bundle {
+  val clk = Output(Bool())
+  val cs = Output(UInt(csWidth.W))
+  val mosi = Output(Bool())
+  val miso = Input(Bool())
+  val irq_out = Output(Bool())
+}
+
+class spi extends BlackBox {
+  val io = IO(new Bundle {
+    val clk = Input(Clock())
+    val resetn = Input(Bool())
+    val in = Flipped(new APBBundle(APBBundleParameters(addrBits = 32, dataBits = 32)))
+    val spi = new SPIIO
+  })
+}
+
+class APBSPI(address: Seq[AddressSet])(implicit p: Parameters) extends LazyModule {
+  val node = APBSlaveNode(Seq(APBSlavePortParameters(
+    Seq(APBSlaveParameters(
+      address       = address,
+      executable    = true,
+      supportsRead  = true,
+      supportsWrite = true)),
+    beatBytes  = 4)))
+
+  lazy val module = new Impl
+  class Impl extends LazyModuleImp(this) {
+    val (in, _) = node.in(0)
+    val spi_bundle = IO(new SPIIO)
+
+    val mspi = Module(new spi)
+    mspi.io.clk := clock
+    mspi.io.resetn := ~reset.asBool
+    mspi.io.in <> in
+    spi_bundle <> mspi.io.spi
+  }
+}
diff --git a/src/device/Uart16550.scala b/src/device/Uart16550.scala
new file mode 100644
index 00000000..afb5c773
--- /dev/null
+++ b/src/device/Uart16550.scala
@@ -0,0 +1,45 @@
+package ysyx
+
+import chisel3._
+import chisel3.util._
+
+import freechips.rocketchip.amba.apb._
+import org.chipsalliance.cde.config.Parameters
+import freechips.rocketchip.diplomacy._
+import freechips.rocketchip.util._
+
+class UARTIO extends Bundle {
+  val rx = Input(Bool())
+  val tx = Output(Bool())
+}
+
+class uart_apb extends BlackBox {
+  val io = IO(new Bundle {
+    val clk = Input(Clock())
+    val resetn = Input(Bool())
+    val in = Flipped(new APBBundle(APBBundleParameters(addrBits = 32, dataBits = 32)))
+    val uart = new UARTIO
+  })
+}
+
+class APBUart16550(address: Seq[AddressSet])(implicit p: Parameters) extends LazyModule {
+  val node = APBSlaveNode(Seq(APBSlavePortParameters(
+    Seq(APBSlaveParameters(
+      address       = address,
+      executable    = false,
+      supportsRead  = true,
+      supportsWrite = true)),
+    beatBytes  = 4)))
+
+  lazy val module = new Impl
+  class Impl extends LazyModuleImp(this) {
+    val (in, _) = node.in(0)
+    val uart = IO(new UARTIO)
+
+    val muart = Module(new uart_apb)
+    muart.io.clk := clock
+    muart.io.resetn := ~reset.asBool
+    muart.io.in <> in
+    uart <> muart.io.uart
+  }
+}
-- 
2.34.1

