From 76b62b6ca1e096cdc372572f72a338c239d0a160 Mon Sep 17 00:00:00 2001
From: Tanghongwei <tanghongwei2024@outlook.com>
Date: Sat, 13 Sep 2025 20:32:50 +0800
Subject: [PATCH 2/2] SoC

---
 perip/amba/apb_delayer.v  | 152 +++++------
 perip/amba/axi4_delayer.v | 530 +++++++++++++++++++-------------------
 rocket-chip               |   2 +-
 3 files changed, 342 insertions(+), 342 deletions(-)

diff --git a/perip/amba/apb_delayer.v b/perip/amba/apb_delayer.v
index 5034ab2b..ffbecd8d 100644
--- a/perip/amba/apb_delayer.v
+++ b/perip/amba/apb_delayer.v
@@ -24,91 +24,91 @@ module apb_delayer(
   input         out_pslverr
 );
 
-  assign out_paddr  = in_paddr;
-  assign out_psel   = in_psel;
-  assign out_penable = in_penable;
-  assign out_pprot  = in_pprot;
-  assign out_pwrite = in_pwrite;
-  assign out_pwdata = in_pwdata;
-  assign out_pstrb  = in_pstrb;
+  // assign out_paddr  = in_paddr;
+  // assign out_psel   = in_psel;
+  // assign out_penable = in_penable;
+  // assign out_pprot  = in_pprot;
+  // assign out_pwrite = in_pwrite;
+  // assign out_pwdata = in_pwdata;
+  // assign out_pstrb  = in_pstrb;
 
-  assign in_pready  = out_pready;
-  assign in_prdata  = out_prdata;
-  assign in_pslverr = out_pslverr;
+  // assign in_pready  = out_pready;
+  // assign in_prdata  = out_prdata;
+  // assign in_pslverr = out_pslverr;
 
-  // localparam IDLE  = 2'b00;
-  // localparam WAIT  = 2'b01;
-  // localparam DELAY = 2'b10;
+  localparam IDLE  = 2'b00;
+  localparam WAIT  = 2'b01;
+  localparam DELAY = 2'b10;
 
-  // reg [ 1:0] state;
-  // reg [31:0] counter;
-  // reg [31:0] prdata_r;
-  // reg pslverr_r;
+  reg [ 1:0] state;
+  reg [31:0] counter;
+  reg [31:0] prdata_r;
+  reg pslverr_r;
 
-  // assign out_paddr   = in_paddr;
-  // assign out_psel    = in_psel && state != DELAY;
-  // assign out_penable = in_penable;
-  // assign out_pprot   = in_pprot;
-  // assign out_pwrite  = in_pwrite;
-  // assign out_pwdata  = in_pwdata;
-  // assign out_pstrb   = in_pstrb;
-  // // assign in_pready   = out_pready;
-  // // assign in_prdata   = out_prdata;
-  // // assign in_pslverr  = out_pslverr;
+  assign out_paddr   = in_paddr;
+  assign out_psel    = in_psel && state != DELAY;
+  assign out_penable = in_penable;
+  assign out_pprot   = in_pprot;
+  assign out_pwrite  = in_pwrite;
+  assign out_pwdata  = in_pwdata;
+  assign out_pstrb   = in_pstrb;
+  // assign in_pready   = out_pready;
+  // assign in_prdata   = out_prdata;
+  // assign in_pslverr  = out_pslverr;
 
-  // // Fmax: 502MHz, Perip: 100MHz, r = 5.02
-  // // set s = 32, r*s = 160.64 -> 161
-  // // wait perip resp: counter 每周期加(r-1)*s=128.64，取整为129
-  // // wait apb delayer done: counter先/s = 129/32*k, 每周期-1
+  // Fmax: 502MHz, Perip: 100MHz, r = 5.02
+  // set s = 32, r*s = 160.64 -> 161
+  // wait perip resp: counter 每周期加(r-1)*s=128.64，取整为129
+  // wait apb delayer done: counter先/s = 129/32*k, 每周期-1
 
-  // localparam delay_cnt = 129;
+  localparam delay_cnt = 129;
 
-  // always @(posedge clock) begin
-  //   if(reset) begin
-  //     state <= IDLE;
-  //     counter <= 32'b0;
-  //   end else begin
-  //     case(state)
-  //       IDLE: begin
-  //         if(in_psel) begin
-  //           state <= WAIT;
-  //           counter <= counter + delay_cnt;
-  //         end
-  //       end
-  //       WAIT: begin
-  //         if(out_pready) begin
-  //           state <= DELAY;
-  //           counter <= (counter + delay_cnt) >> 5;
-  //         end else begin
-  //           counter <= counter + delay_cnt;
-  //         end
-  //       end
-  //       DELAY: begin
-  //         if(counter == 32'b1) begin
-  //           state <= IDLE;
-  //           counter <= 32'b0;
-  //         end else begin
-  //           counter <= counter - 1'b1;
-  //         end
-  //       end
-  //       default: state <= IDLE;
-  //     endcase
-  //   end
-  // end
+  always @(posedge clock) begin
+    if(reset) begin
+      state <= IDLE;
+      counter <= 32'b0;
+    end else begin
+      case(state)
+        IDLE: begin
+          if(in_psel) begin
+            state <= WAIT;
+            counter <= counter + delay_cnt;
+          end
+        end
+        WAIT: begin
+          if(out_pready) begin
+            state <= DELAY;
+            counter <= (counter + delay_cnt) >> 5;
+          end else begin
+            counter <= counter + delay_cnt;
+          end
+        end
+        DELAY: begin
+          if(counter == 32'b1) begin
+            state <= IDLE;
+            counter <= 32'b0;
+          end else begin
+            counter <= counter - 1'b1;
+          end
+        end
+        default: state <= IDLE;
+      endcase
+    end
+  end
 
-  // always @(posedge clock) begin
-  //   if(reset) begin
-  //     prdata_r <= 32'b0;
-  //     pslverr_r <= 1'b0;
-  //   end else if(out_pready) begin
-  //     prdata_r <= out_prdata;
-  //     pslverr_r <= out_pslverr;
-  //   end
-  // end
+  always @(posedge clock) begin
+    if(reset) begin
+      prdata_r <= 32'b0;
+      pslverr_r <= 1'b0;
+    end else if(out_pready) begin
+      prdata_r <= out_prdata;
+      pslverr_r <= out_pslverr;
+    end
+  end
 
 
-  // assign in_pready = state == DELAY && counter == 32'b1;
-  // assign in_prdata   = prdata_r;
-  // assign in_pslverr  = pslverr_r;
+  assign in_pready = state == DELAY && counter == 32'b1;
+  assign in_prdata   = prdata_r;
+  assign in_pslverr  = pslverr_r;
 
 endmodule
diff --git a/perip/amba/axi4_delayer.v b/perip/amba/axi4_delayer.v
index a58d819f..4d54a5b7 100644
--- a/perip/amba/axi4_delayer.v
+++ b/perip/amba/axi4_delayer.v
@@ -63,300 +63,300 @@ module axi4_delayer(
   input  [1:0]  out_bresp
 );
 
-  assign out_arvalid = in_arvalid;
-  assign out_arid    = in_arid;
-  assign out_araddr  = in_araddr;
-  assign out_arlen   = in_arlen;
-  assign out_arsize  = in_arsize;
-  assign out_arburst = in_arburst;
-  assign in_arready  = out_arready;
+  // assign out_arvalid = in_arvalid;
+  // assign out_arid    = in_arid;
+  // assign out_araddr  = in_araddr;
+  // assign out_arlen   = in_arlen;
+  // assign out_arsize  = in_arsize;
+  // assign out_arburst = in_arburst;
+  // assign in_arready  = out_arready;
 
-  assign in_rvalid = out_rvalid;
-  assign in_rid    = out_rid;
-  assign in_rdata  = out_rdata;
-  assign in_rresp  = out_rresp;
-  assign in_rlast  = out_rlast;
-  assign out_rready = in_rready;
+  // assign in_rvalid = out_rvalid;
+  // assign in_rid    = out_rid;
+  // assign in_rdata  = out_rdata;
+  // assign in_rresp  = out_rresp;
+  // assign in_rlast  = out_rlast;
+  // assign out_rready = in_rready;
 
-  assign out_awvalid = in_awvalid;
-  assign out_awid    = in_awid;
-  assign out_awaddr  = in_awaddr;
-  assign out_awlen   = in_awlen;
-  assign out_awsize  = in_awsize;
-  assign out_awburst = in_awburst;
-  assign in_awready  = out_awready;
+  // assign out_awvalid = in_awvalid;
+  // assign out_awid    = in_awid;
+  // assign out_awaddr  = in_awaddr;
+  // assign out_awlen   = in_awlen;
+  // assign out_awsize  = in_awsize;
+  // assign out_awburst = in_awburst;
+  // assign in_awready  = out_awready;
 
-  assign out_wvalid = in_wvalid;
-  assign out_wdata  = in_wdata;
-  assign out_wstrb  = in_wstrb;
-  assign out_wlast  = in_wlast;
-  assign in_wready  = out_wready;
+  // assign out_wvalid = in_wvalid;
+  // assign out_wdata  = in_wdata;
+  // assign out_wstrb  = in_wstrb;
+  // assign out_wlast  = in_wlast;
+  // assign in_wready  = out_wready;
 
-  assign in_bvalid = out_bvalid;
-  assign in_bid    = out_bid;
-  assign in_bresp  = out_bresp;
-  assign out_bready = in_bready;
+  // assign in_bvalid = out_bvalid;
+  // assign in_bid    = out_bid;
+  // assign in_bresp  = out_bresp;
+  // assign out_bready = in_bready;
 
   // Fmax: 502MHz, Perip: 100MHz, r = 5.02
   // set s = 32, r*s = 160.64 -> 161
   // wait perip resp: counter 每周期加(r-1)*s=128.64，取整为129
   // wait apb delayer done: counter先/s = 129/32*k, 每周期-1
 
-  // localparam delay_cnt = 129;
-  // 
-  // localparam AR_IDLE      = 2'b00;
-  // localparam AR_WAIT      = 2'b01;
-  // localparam R_WAIT       = 2'b10;
-  // localparam R_DELAY      = 2'b11;
+  localparam delay_cnt = 129;
+  
+  localparam AR_IDLE      = 2'b00;
+  localparam AR_WAIT      = 2'b01;
+  localparam R_WAIT       = 2'b10;
+  localparam R_DELAY      = 2'b11;
 
-  // localparam AW_IDLE      = 2'b00;
-  // localparam AW_WAIT      = 2'b01;
-  // localparam W_WAIT       = 2'b10;
-  // localparam W_DELAY      = 2'b11;
+  localparam AW_IDLE      = 2'b00;
+  localparam AW_WAIT      = 2'b01;
+  localparam W_WAIT       = 2'b10;
+  localparam W_DELAY      = 2'b11;
 
-  // reg [ 1:0] r_state;
-  // reg [31:0] r_counter;
-  // reg [31:0] r_burst_num;
-  // reg        r_burst_start;
-  // reg        r_burst_end;
-  // reg [31:0] r_burst_counter;
+  reg [ 1:0] r_state;
+  reg [31:0] r_counter;
+  reg [31:0] r_burst_num;
+  reg        r_burst_start;
+  reg        r_burst_end;
+  reg [31:0] r_burst_counter;
 
-  // reg [ 1:0] w_state;
-  // reg [31:0] w_counter;
-  // reg [31:0] w_burst_num;
-  // reg        w_burst_start;
-  // reg        w_burst_end;
-  // reg [31:0] w_burst_counter;
+  reg [ 1:0] w_state;
+  reg [31:0] w_counter;
+  reg [31:0] w_burst_num;
+  reg        w_burst_start;
+  reg        w_burst_end;
+  reg [31:0] w_burst_counter;
 
-  // reg  [33:0] r_req_data;
-  // wire [33:0] r_req_out;
+  reg  [33:0] r_req_data;
+  wire [33:0] r_req_out;
 
-  // reg  [ 1:0] w_req_data;
-  // wire [ 1:0] w_req_out;
+  reg  [ 1:0] w_req_data;
+  wire [ 1:0] w_req_out;
 
-  // fifo
-  // #(
-    // .WIDTH   (34),
-    // .DEPTH   (8),
-    // .ADDR_W  (3)
-  // ) u_requests (
-    // .clk_i    (clock),
-    // .rst_i    (reset),
-    // .data_in_i (r_req_data),
-    // .push_i   (out_rvalid),
-    // .pop_i    (in_rvalid),
-    // .data_out_o (r_req_out),
-    // .accept_o (),
-    // .valid_o  ()
-  // );
-  // fifo
-  // #(
-    // .WIDTH   (2),
-    // .DEPTH   (8),
-    // .ADDR_W  (3)
-  // ) u_response (
-    // .clk_i    (clock),
-    // .rst_i    (reset),
-    // .data_in_i (w_req_data),
-    // .push_i   (out_wvalid),
-    // .pop_i    (in_wvalid),
-    // .data_out_o (w_req_out),
-    // .accept_o (),
-    // .valid_o  ()
-  // );
+  fifo
+  #(
+    .WIDTH   (34),
+    .DEPTH   (8),
+    .ADDR_W  (3)
+  ) u_requests (
+    .clk_i    (clock),
+    .rst_i    (reset),
+    .data_in_i (r_req_data),
+    .push_i   (out_rvalid),
+    .pop_i    (in_rvalid),
+    .data_out_o (r_req_out),
+    .accept_o (),
+    .valid_o  ()
+  );
+  fifo
+  #(
+    .WIDTH   (2),
+    .DEPTH   (8),
+    .ADDR_W  (3)
+  ) u_response (
+    .clk_i    (clock),
+    .rst_i    (reset),
+    .data_in_i (w_req_data),
+    .push_i   (out_wvalid),
+    .pop_i    (in_wvalid),
+    .data_out_o (w_req_out),
+    .accept_o (),
+    .valid_o  ()
+  );
 
-  // always @(*) begin
-    // r_req_data = {out_rresp, out_rdata};
-    // w_req_data = {out_bresp};
-  // end
+  always @(*) begin
+    r_req_data = {out_rresp, out_rdata};
+    w_req_data = {out_bresp};
+  end
 
-  // assign out_arid     = in_arid;
-  // assign out_araddr   = in_araddr;
-  // assign out_arlen    = in_arlen;
-  // assign out_arsize   = in_arsize;
-  // assign out_arburst  = in_arburst;
-  // assign out_arvalid  = (r_state == AR_WAIT) ? in_arvalid : 1'b0;
-  // assign in_arready   = (r_state == R_WAIT) ? 1'b1 : 1'b0;
-  // 
-  // assign out_rready   = in_rready;
-  // assign in_rid       = out_rid;
-  // assign in_rdata     = r_req_out[31: 0];
-  // assign in_rresp     = r_req_out[33:32];
-  // assign in_rlast     = (r_state == R_DELAY && r_counter == 32'b1 && r_burst_num == 32'b1) ? 1'b1 : 1'b0;
-  // assign in_rvalid    = (r_state == R_DELAY && r_counter == 32'b1) ? 1'b1 : 1'b0;
-  // 
-  // assign out_awid     = in_awid;
-  // assign out_awaddr   = in_awaddr;
-  // assign out_awlen    = in_awlen;
-  // assign out_awsize   = in_awsize;
-  // assign out_awburst  = in_awburst;
-  // assign out_awvalid  = (w_state == AW_WAIT) ? in_awvalid : 1'b0;
-  // assign in_awready   = (w_state == W_WAIT) ? 1'b1 : 1'b0;
-  // assign out_wdata    = in_wdata;
-  // assign out_wstrb    = in_wstrb;
-  // assign out_wlast    = in_wlast;
-  // assign out_wvalid   = (w_state == AW_WAIT) ? in_wvalid : 1'b0;
-  // assign in_wready    = (w_state == W_WAIT) ? 1'b1 : 1'b0;
-  // 
-  // assign out_bready   = in_bready;
-  // assign in_bid       = out_bid;
-  // assign in_bresp     = w_req_out[1:0];
-  // assign in_bvalid    = (w_state == W_DELAY && w_counter == 32'b1) ? 1'b1 : 1'b0;
+  assign out_arid     = in_arid;
+  assign out_araddr   = in_araddr;
+  assign out_arlen    = in_arlen;
+  assign out_arsize   = in_arsize;
+  assign out_arburst  = in_arburst;
+  assign out_arvalid  = (r_state == AR_WAIT) ? in_arvalid : 1'b0;
+  assign in_arready   = (r_state == R_WAIT) ? 1'b1 : 1'b0;
+  
+  assign out_rready   = in_rready;
+  assign in_rid       = out_rid;
+  assign in_rdata     = r_req_out[31: 0];
+  assign in_rresp     = r_req_out[33:32];
+  assign in_rlast     = (r_state == R_DELAY && r_counter == 32'b1 && r_burst_num == 32'b1) ? 1'b1 : 1'b0;
+  assign in_rvalid    = (r_state == R_DELAY && r_counter == 32'b1) ? 1'b1 : 1'b0;
+  
+  assign out_awid     = in_awid;
+  assign out_awaddr   = in_awaddr;
+  assign out_awlen    = in_awlen;
+  assign out_awsize   = in_awsize;
+  assign out_awburst  = in_awburst;
+  assign out_awvalid  = (w_state == AW_WAIT) ? in_awvalid : 1'b0;
+  assign in_awready   = (w_state == W_WAIT) ? 1'b1 : 1'b0;
+  assign out_wdata    = in_wdata;
+  assign out_wstrb    = in_wstrb;
+  assign out_wlast    = in_wlast;
+  assign out_wvalid   = (w_state == AW_WAIT) ? in_wvalid : 1'b0;
+  assign in_wready    = (w_state == W_WAIT) ? 1'b1 : 1'b0;
+  
+  assign out_bready   = in_bready;
+  assign in_bid       = out_bid;
+  assign in_bresp     = w_req_out[1:0];
+  assign in_bvalid    = (w_state == W_DELAY && w_counter == 32'b1) ? 1'b1 : 1'b0;
 
-  // always @(posedge clock) begin
-    // if (reset) begin
-      // r_state <= AR_IDLE;
-      // r_counter <= 32'b0;
-    // end else begin
-      // case (r_state)
-        // AR_IDLE: begin
-          // if (in_arvalid) begin
-            // r_state <= AR_WAIT;
-            // r_counter <= r_counter + delay_cnt;
-          // end
-        // end
-        // AR_WAIT: begin
-          // if (out_arready) begin
-            // r_state <= R_WAIT;
-          // end
-          // r_counter <= r_counter + delay_cnt;
-        // end
-        // R_WAIT: begin
-          // if (out_rlast & out_rvalid) begin
-            // r_state <= R_DELAY;
-            // r_burst_num <= r_burst_num + 32'b1;
-            // r_counter <= (r_counter + delay_cnt) >> 5;
-            // r_burst_counter <= (r_burst_counter + delay_cnt) >> 5;
-          // end else begin
-            // if(out_rvalid) begin
-              // r_burst_start <= 1'b1;
-              // r_burst_end <= r_burst_start ? 1'b1 : 1'b0;
-              // r_burst_num <= r_burst_num + 32'b1;
-            // end
-            // r_burst_counter <= (r_burst_start ^ r_burst_end) ? r_burst_counter + delay_cnt : r_burst_counter;
-            // r_counter <= r_burst_start ? r_counter : r_counter + delay_cnt;
-          // end
-        // end
-        // R_DELAY: begin
-          // if (r_counter == 32'b1) begin
-            // if(r_burst_num == 32'b1) begin
-              // r_state <= AR_IDLE;
-              // r_burst_num <= 32'b0;
-              // r_counter <= 32'b0;
-              // r_burst_counter <= 32'b0;
-              // r_burst_start <= 1'b0;
-              // r_burst_end <= 1'b0;
-            // end else begin
-              // r_burst_num <= r_burst_num - 32'b1;
-              // r_counter <= r_burst_counter;
-            // end
-          // end else begin
-            // r_counter <= r_counter - 1'b1;
-          // end
-        // end
-        // default: r_state <= AR_IDLE;
-      // endcase
-    // end
-  // end
+  always @(posedge clock) begin
+    if (reset) begin
+      r_state <= AR_IDLE;
+      r_counter <= 32'b0;
+    end else begin
+      case (r_state)
+        AR_IDLE: begin
+          if (in_arvalid) begin
+            r_state <= AR_WAIT;
+            r_counter <= r_counter + delay_cnt;
+          end
+        end
+        AR_WAIT: begin
+          if (out_arready) begin
+            r_state <= R_WAIT;
+          end
+          r_counter <= r_counter + delay_cnt;
+        end
+        R_WAIT: begin
+          if (out_rlast & out_rvalid) begin
+            r_state <= R_DELAY;
+            r_burst_num <= r_burst_num + 32'b1;
+            r_counter <= (r_counter + delay_cnt) >> 5;
+            r_burst_counter <= (r_burst_counter + delay_cnt) >> 5;
+          end else begin
+            if(out_rvalid) begin
+              r_burst_start <= 1'b1;
+              r_burst_end <= r_burst_start ? 1'b1 : 1'b0;
+              r_burst_num <= r_burst_num + 32'b1;
+            end
+            r_burst_counter <= (r_burst_start ^ r_burst_end) ? r_burst_counter + delay_cnt : r_burst_counter;
+            r_counter <= r_burst_start ? r_counter : r_counter + delay_cnt;
+          end
+        end
+        R_DELAY: begin
+          if (r_counter == 32'b1) begin
+            if(r_burst_num == 32'b1) begin
+              r_state <= AR_IDLE;
+              r_burst_num <= 32'b0;
+              r_counter <= 32'b0;
+              r_burst_counter <= 32'b0;
+              r_burst_start <= 1'b0;
+              r_burst_end <= 1'b0;
+            end else begin
+              r_burst_num <= r_burst_num - 32'b1;
+              r_counter <= r_burst_counter;
+            end
+          end else begin
+            r_counter <= r_counter - 1'b1;
+          end
+        end
+        default: r_state <= AR_IDLE;
+      endcase
+    end
+  end
 
-  // always @(posedge clock) begin
-    // if (reset) begin
-      // w_state <= AW_IDLE;
-      // w_counter <= 32'b0;
-    // end else begin
-      // case (w_state)
-        // AW_IDLE: begin
-          // if (in_awvalid) begin
-            // w_state <= AW_WAIT;
-            // w_counter <= w_counter + delay_cnt;
-          // end
-        // end
-        // AW_WAIT: begin
-          // w_counter <= w_counter + delay_cnt;
-          // if (out_awready) begin
-            // w_state <= W_WAIT;
-          // end
-          // w_counter <= w_counter + delay_cnt;
-        // end
-        // W_WAIT: begin
-          // if (out_bvalid) begin
-            // w_state <= W_DELAY;
-            // w_counter <= (w_counter + delay_cnt) >> 5;
-          // end else begin
-            // w_counter <= w_counter + delay_cnt;
-          // end
-        // end
-        // W_DELAY: begin
-          // if (w_counter == 32'b1) begin
-            // if (in_wlast) begin
-              // w_state <= AW_IDLE;
-              // w_counter <= 32'b0;
-            // end else begin
-              // w_state <= W_WAIT;
-              // w_counter <= 32'b0;
-            // end
-          // end else begin
-            // w_counter <= w_counter - 1'b1;
-          // end
-        // end
-        // default: w_state <= AW_IDLE;
-      // endcase
-    // end
-  // end
+  always @(posedge clock) begin
+    if (reset) begin
+      w_state <= AW_IDLE;
+      w_counter <= 32'b0;
+    end else begin
+      case (w_state)
+        AW_IDLE: begin
+          if (in_awvalid) begin
+            w_state <= AW_WAIT;
+            w_counter <= w_counter + delay_cnt;
+          end
+        end
+        AW_WAIT: begin
+          w_counter <= w_counter + delay_cnt;
+          if (out_awready) begin
+            w_state <= W_WAIT;
+          end
+          w_counter <= w_counter + delay_cnt;
+        end
+        W_WAIT: begin
+          if (out_bvalid) begin
+            w_state <= W_DELAY;
+            w_counter <= (w_counter + delay_cnt) >> 5;
+          end else begin
+            w_counter <= w_counter + delay_cnt;
+          end
+        end
+        W_DELAY: begin
+          if (w_counter == 32'b1) begin
+            if (in_wlast) begin
+              w_state <= AW_IDLE;
+              w_counter <= 32'b0;
+            end else begin
+              w_state <= W_WAIT;
+              w_counter <= 32'b0;
+            end
+          end else begin
+            w_counter <= w_counter - 1'b1;
+          end
+        end
+        default: w_state <= AW_IDLE;
+      endcase
+    end
+  end
 
-// endmodule
+endmodule
 
-// module fifo
-// #(
-  // parameter WIDTH   = 32,
-  // parameter DEPTH   = 8,
-  // parameter ADDR_W  = 3
-// ) (
-  //  input               clk_i
-  // ,input               rst_i
-  // ,input  [WIDTH-1:0]  data_in_i
-  // ,input               push_i
-  // ,input               pop_i
+module fifo
+#(
+  parameter WIDTH   = 32,
+  parameter DEPTH   = 8,
+  parameter ADDR_W  = 3
+) (
+   input               clk_i
+  ,input               rst_i
+  ,input  [WIDTH-1:0]  data_in_i
+  ,input               push_i
+  ,input               pop_i
 
-  // ,output [WIDTH-1:0]  data_out_o
-  // ,output              accept_o
-  // ,output              valid_o
-// );
+  ,output [WIDTH-1:0]  data_out_o
+  ,output              accept_o
+  ,output              valid_o
+);
 
-// localparam COUNT_W = ADDR_W + 1;
+localparam COUNT_W = ADDR_W + 1;
 
-// reg [WIDTH-1:0]         ram [DEPTH-1:0];
-// reg [ADDR_W-1:0]        rd_ptr;
-// reg [ADDR_W-1:0]        wr_ptr;
-// reg [COUNT_W-1:0]       count;
+reg [WIDTH-1:0]         ram [DEPTH-1:0];
+reg [ADDR_W-1:0]        rd_ptr;
+reg [ADDR_W-1:0]        wr_ptr;
+reg [COUNT_W-1:0]       count;
 
-// always @ (posedge clk_i or posedge rst_i)
-// if (rst_i)
-// begin
-    // count   <= {(COUNT_W) {1'b0}};
-    // rd_ptr  <= {(ADDR_W) {1'b0}};
-    // wr_ptr  <= {(ADDR_W) {1'b0}};
-// end
-// else
-// begin
-    // if (push_i & accept_o)
-    // begin
-      // ram[wr_ptr] <= data_in_i;
-      // wr_ptr      <= wr_ptr + 1;
-    // end
+always @ (posedge clk_i or posedge rst_i)
+if (rst_i)
+begin
+    count   <= {(COUNT_W) {1'b0}};
+    rd_ptr  <= {(ADDR_W) {1'b0}};
+    wr_ptr  <= {(ADDR_W) {1'b0}};
+end
+else
+begin
+    if (push_i & accept_o)
+    begin
+      ram[wr_ptr] <= data_in_i;
+      wr_ptr      <= wr_ptr + 1;
+    end
 
-    // if (pop_i & valid_o)
-      // rd_ptr      <= rd_ptr + 1;
+    if (pop_i & valid_o)
+      rd_ptr      <= rd_ptr + 1;
 
-    // if ((push_i & accept_o) & ~(pop_i & valid_o))
-        // count <= count + 1;
-    // else if (~(push_i & accept_o) & (pop_i & valid_o))
-        // count <= count - 1;
-// end
+    if ((push_i & accept_o) & ~(pop_i & valid_o))
+        count <= count + 1;
+    else if (~(push_i & accept_o) & (pop_i & valid_o))
+        count <= count - 1;
+end
 
-// assign accept_o   = (count != DEPTH);
-// assign valid_o    = (count != 0);
+assign accept_o   = (count != DEPTH);
+assign valid_o    = (count != 0);
 
-// assign data_out_o = ram[rd_ptr];
+assign data_out_o = ram[rd_ptr];
 
 endmodule
diff --git a/rocket-chip b/rocket-chip
index d0c6b50f..c8f225f5 160000
--- a/rocket-chip
+++ b/rocket-chip
@@ -1 +1 @@
-Subproject commit d0c6b50fdefcdbe121e9788433ea51f7efaf1d32
+Subproject commit c8f225f5157549312f573be552af802aac200ff2
-- 
2.34.1

