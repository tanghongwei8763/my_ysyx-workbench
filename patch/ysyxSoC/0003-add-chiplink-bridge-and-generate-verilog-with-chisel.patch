From 0c5f00c3e72ea4f593ab14ddc8f2113b44b4b252 Mon Sep 17 00:00:00 2001
From: Zihao Yu <yuzihao@ict.ac.cn>
Date: Thu, 26 Aug 2021 14:57:34 +0800
Subject: [PATCH 03/74] add chiplink bridge and generate verilog with chisel
 7.0.0-M1

---
 .gitignore                      |   2 +
 Makefile                        |  20 +++
 build.sc                        |  66 +++++++
 patch/rocket-chip.patch         | 297 ++++++++++++++++++++++++++++++++
 src/Top.scala                   |  23 +++
 src/chiplink/Bundles.scala      |  54 +++---
 src/chiplink/CAM.scala          |   6 +-
 src/chiplink/ChipLink.scala     |  25 +--
 src/chiplink/Parameters.scala   |  40 ++---
 src/chiplink/Partial.scala      |  64 +++----
 src/chiplink/RX.scala           |  50 +++---
 src/chiplink/SinkA.scala        |  34 ++--
 src/chiplink/SinkB.scala        |  36 ++--
 src/chiplink/SinkC.scala        |  38 ++--
 src/chiplink/SinkD.scala        |  38 ++--
 src/chiplink/SinkE.scala        |  30 ++--
 src/chiplink/SourceA.scala      |  40 ++---
 src/chiplink/SourceB.scala      |  30 ++--
 src/chiplink/SourceC.scala      |  36 ++--
 src/chiplink/SourceD.scala      |  32 ++--
 src/chiplink/SourceE.scala      |  10 +-
 src/chiplink/StuckSnooper.scala |  45 ++---
 src/chiplink/TX.scala           |  87 +++++-----
 src/device/ChipLinkBridge.scala | 171 ++++++++++++++++++
 24 files changed, 932 insertions(+), 342 deletions(-)
 create mode 100644 .gitignore
 create mode 100644 Makefile
 create mode 100644 build.sc
 create mode 100644 patch/rocket-chip.patch
 create mode 100644 src/Top.scala
 create mode 100644 src/device/ChipLinkBridge.scala

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 00000000..3c0160d0
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,2 @@
+build/
+out/
diff --git a/Makefile b/Makefile
new file mode 100644
index 00000000..6d76a223
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,20 @@
+V_FILE_GEN   = build/ysyxSoCTop.sv
+V_FILE_FINAL = build/ysyxSoCFull.v
+SCALA_FILES = $(shell find src/ -name "*.scala")
+
+$(V_FILE_FINAL): $(SCALA_FILES)
+	mill -i ysyxsoc.runMain ysyx.Elaborate --target-dir $(@D)
+	mv $(V_FILE_GEN) $@
+	sed -i -e 's/_\(aw\|ar\|w\|r\|b\)_\(\|bits_\)/_\1/g' $@
+	sed -i '/firrtl_black_box_resource_files.f/, $$d' $@
+
+verilog: $(V_FILE_FINAL)
+
+clean:
+	-rm -rf build/
+
+dev-init:
+	git submodule update --init --recursive
+	cd rocket-chip && git apply ../patch/rocket-chip.patch
+
+.PHONY: verilog clean dev-init
diff --git a/build.sc b/build.sc
new file mode 100644
index 00000000..d858e004
--- /dev/null
+++ b/build.sc
@@ -0,0 +1,66 @@
+import mill._
+import scalalib._
+import $file.`rocket-chip`.common
+import $file.`rocket-chip`.cde.common
+import $file.`rocket-chip`.hardfloat.build
+
+val chiselVersion = "7.0.0-M1"
+val defaultScalaVersion = "2.13.10"
+
+trait HasChisel extends SbtModule {
+  def chiselModule: Option[ScalaModule] = None
+  def chiselPluginJar: T[Option[PathRef]] = None
+  def chiselIvy: Option[Dep] = Some(ivy"org.chipsalliance::chisel:${chiselVersion}")
+  def chiselPluginIvy: Option[Dep] = Some(ivy"org.chipsalliance:::chisel-plugin:${chiselVersion}")
+  override def scalaVersion = defaultScalaVersion
+  override def scalacOptions = super.scalacOptions() ++
+    Agg("-language:reflectiveCalls", "-Ymacro-annotations", "-Ytasty-reader")
+  override def ivyDeps = super.ivyDeps() ++ Agg(chiselIvy.get)
+  override def scalacPluginIvyDeps = super.scalacPluginIvyDeps() ++ Agg(chiselPluginIvy.get)
+}
+
+object rocketchip extends RocketChip
+trait RocketChip extends millbuild.`rocket-chip`.common.RocketChipModule with HasChisel {
+  def scalaVersion: T[String] = T(defaultScalaVersion)
+  override def millSourcePath = os.pwd / "rocket-chip"
+  def dependencyPath = millSourcePath
+  def macrosModule = macros
+  def hardfloatModule = hardfloat
+  def cdeModule = cde
+  def mainargsIvy = ivy"com.lihaoyi::mainargs:0.5.4"
+  def json4sJacksonIvy = ivy"org.json4s::json4s-jackson:4.0.6"
+
+  object macros extends Macros
+  trait Macros extends millbuild.`rocket-chip`.common.MacrosModule with SbtModule {
+    def scalaVersion: T[String] = T(defaultScalaVersion)
+    def scalaReflectIvy = ivy"org.scala-lang:scala-reflect:${defaultScalaVersion}"
+  }
+
+  object hardfloat extends Hardfloat
+  trait Hardfloat extends millbuild.`rocket-chip`.hardfloat.common.HardfloatModule with HasChisel {
+    def scalaVersion: T[String] = T(defaultScalaVersion)
+    override def millSourcePath = dependencyPath / "hardfloat" / "hardfloat"
+  }
+
+  object cde extends CDE
+  trait CDE extends millbuild.`rocket-chip`.cde.common.CDEModule with ScalaModule {
+    def scalaVersion: T[String] = T(defaultScalaVersion)
+    override def millSourcePath = dependencyPath / "cde" / "cde"
+  }
+}
+
+trait ysyxSoCModule extends ScalaModule {
+  def rocketModule: ScalaModule
+  override def moduleDeps = super.moduleDeps ++ Seq(
+    rocketModule,
+  )
+}
+
+object ysyxsoc extends ysyxSoC
+trait ysyxSoC extends ysyxSoCModule with HasChisel {
+  override def millSourcePath = os.pwd
+  def rocketModule = rocketchip
+  override def sources = T.sources {
+    super.sources() ++ Seq(PathRef(millSourcePath / "src"))
+  }
+}
diff --git a/patch/rocket-chip.patch b/patch/rocket-chip.patch
new file mode 100644
index 00000000..3f6ce479
--- /dev/null
+++ b/patch/rocket-chip.patch
@@ -0,0 +1,297 @@
+diff --git a/src/main/resources/META-INF/services/firrtl.options.RegisteredLibrary b/src/main/resources/META-INF/services/firrtl.options.RegisteredLibrary
+index abfcceb05..e69de29bb 100644
+--- a/src/main/resources/META-INF/services/firrtl.options.RegisteredLibrary
++++ b/src/main/resources/META-INF/services/firrtl.options.RegisteredLibrary
+@@ -1 +0,0 @@
+-firrtl.passes.memlib.MemLibOptions
+diff --git a/src/main/scala/diplomacy/BundleBridge.scala b/src/main/scala/diplomacy/BundleBridge.scala
+index e02d6f4f9..0e2eef8ba 100644
+--- a/src/main/scala/diplomacy/BundleBridge.scala
++++ b/src/main/scala/diplomacy/BundleBridge.scala
+@@ -3,8 +3,9 @@
+ package freechips.rocketchip.diplomacy
+ 
+ import chisel3._
+-import chisel3.experimental.{DataMirror, SourceInfo}
+-import chisel3.experimental.DataMirror.internal.chiselTypeClone
++import chisel3.experimental.SourceInfo
++import chisel3.reflect.DataMirror
++import chisel3.reflect.DataMirror.internal.chiselTypeClone
+ import org.chipsalliance.cde.config.Parameters
+ import freechips.rocketchip.util.DataToAugmentedData
+ 
+diff --git a/src/main/scala/diplomacy/LazyModule.scala b/src/main/scala/diplomacy/LazyModule.scala
+index 5f4da46cb..418873331 100644
+--- a/src/main/scala/diplomacy/LazyModule.scala
++++ b/src/main/scala/diplomacy/LazyModule.scala
+@@ -3,7 +3,7 @@
+ package freechips.rocketchip.diplomacy
+ 
+ import chisel3._
+-import chisel3.internal.sourceinfo.{SourceInfo, UnlocatableSourceInfo}
++import chisel3.experimental.{SourceInfo, UnlocatableSourceInfo}
+ import chisel3.{Module, RawModule, Reset, withClockAndReset}
+ import chisel3.experimental.{ChiselAnnotation, CloneModuleAsRecord}
+ import firrtl.passes.InlineAnnotation
+diff --git a/src/main/scala/groundtest/TraceGen.scala b/src/main/scala/groundtest/TraceGen.scala
+index 5c5cba9b5..05f6e0029 100644
+--- a/src/main/scala/groundtest/TraceGen.scala
++++ b/src/main/scala/groundtest/TraceGen.scala
+@@ -186,7 +186,7 @@ class TagMan(val logNumTags : Int) extends Module {
+   io.tagOut := nextTag
+ 
+   // Is the next tag available?
+-  io.available := ~MuxLookup(nextTag, true.B, inUseMap)
++  io.available := ~MuxLookup(nextTag, true.B)(inUseMap)
+ 
+   // When user takes a tag
+   when (io.take) {
+@@ -249,7 +249,7 @@ class TraceGenerator(val params: TraceGenParams)(implicit val p: Parameters) ext
+   val addrBagIndices = (0 to addressBagLen-1).
+                     map(i => i.U(logAddressBagLen.W))
+ 
+-  val randAddrFromBag = MuxLookup(randAddrBagIndex, 0.U,
++  val randAddrFromBag = MuxLookup(randAddrBagIndex, 0.U)(
+                           addrBagIndices.zip(bagOfAddrs))
+ 
+   // Random address from the address bag or the extra addresses.
+@@ -268,7 +268,7 @@ class TraceGenerator(val params: TraceGenParams)(implicit val p: Parameters) ext
+ 
+           // A random address from the extra addresses.
+           val randAddrFromExtra = Cat(0.U,
+-                MuxLookup(randExtraAddrIndex, 0.U,
++                MuxLookup(randExtraAddrIndex, 0.U)(
+                   extraAddrIndices.zip(extraAddrs)), 0.U(3.W))
+ 
+           Frequency(List(
+@@ -279,7 +279,7 @@ class TraceGenerator(val params: TraceGenParams)(implicit val p: Parameters) ext
+   val allAddrs = extraAddrs ++ bagOfAddrs
+   val allAddrIndices = (0 until totalNumAddrs)
+     .map(i => i.U(log2Ceil(totalNumAddrs).W))
+-  val initAddr = MuxLookup(initCount, 0.U,
++  val initAddr = MuxLookup(initCount, 0.U)(
+     allAddrIndices.zip(allAddrs))
+ 
+   // Random opcodes
+diff --git a/src/main/scala/jtag/JtagShifter.scala b/src/main/scala/jtag/JtagShifter.scala
+index 69f6d1272..d76ac3535 100644
+--- a/src/main/scala/jtag/JtagShifter.scala
++++ b/src/main/scala/jtag/JtagShifter.scala
+@@ -3,7 +3,7 @@
+ package freechips.rocketchip.jtag
+ 
+ import chisel3._
+-import chisel3.experimental.DataMirror
++import chisel3.reflect.DataMirror
+ import chisel3.internal.firrtl.KnownWidth
+ import chisel3.util.{Cat, Valid}
+ 
+diff --git a/src/main/scala/rocket/BTB.scala b/src/main/scala/rocket/BTB.scala
+index 25b5b359d..75126dd12 100644
+--- a/src/main/scala/rocket/BTB.scala
++++ b/src/main/scala/rocket/BTB.scala
+@@ -5,7 +5,6 @@ package freechips.rocketchip.rocket
+ 
+ import chisel3._
+ import chisel3.util._
+-import chisel3.internal.InstanceId
+ import org.chipsalliance.cde.config.Parameters
+ import freechips.rocketchip.subsystem.CacheBlockBytes
+ import freechips.rocketchip.tile.HasCoreParameters
+diff --git a/src/main/scala/rocket/DCache.scala b/src/main/scala/rocket/DCache.scala
+index 308392aca..66aa0715f 100644
+--- a/src/main/scala/rocket/DCache.scala
++++ b/src/main/scala/rocket/DCache.scala
+@@ -561,7 +561,7 @@ class DCacheModule(outer: DCache) extends HellaCacheModule(outer) {
+   val put     = edge.Put(a_source, access_address, a_size, a_data)._2
+   val putpartial = edge.Put(a_source, access_address, a_size, a_data, a_mask)._2
+   val atomics = if (edge.manager.anySupportLogical) {
+-    MuxLookup(s2_req.cmd, WireDefault(0.U.asTypeOf(new TLBundleA(edge.bundle))), Array(
++    MuxLookup(s2_req.cmd, WireDefault(0.U.asTypeOf(new TLBundleA(edge.bundle))))(Array(
+       M_XA_SWAP -> edge.Logical(a_source, access_address, a_size, a_data, TLAtomics.SWAP)._2,
+       M_XA_XOR  -> edge.Logical(a_source, access_address, a_size, a_data, TLAtomics.XOR) ._2,
+       M_XA_OR   -> edge.Logical(a_source, access_address, a_size, a_data, TLAtomics.OR)  ._2,
+diff --git a/src/main/scala/rocket/NBDcache.scala b/src/main/scala/rocket/NBDcache.scala
+index f9161dd5d..510fe1f5e 100644
+--- a/src/main/scala/rocket/NBDcache.scala
++++ b/src/main/scala/rocket/NBDcache.scala
+@@ -82,7 +82,7 @@ class IOMSHR(id: Int)(implicit edge: TLEdgeOut, p: Parameters) extends L1HellaCa
+   val get     = edge.Get(a_source, a_address, a_size)._2
+   val put     = edge.Put(a_source, a_address, a_size, a_data)._2
+   val atomics = if (edge.manager.anySupportLogical) {
+-    MuxLookup(req.cmd, (0.U).asTypeOf(new TLBundleA(edge.bundle)), Array(
++    MuxLookup(req.cmd, (0.U).asTypeOf(new TLBundleA(edge.bundle)))(Array(
+       M_XA_SWAP -> edge.Logical(a_source, a_address, a_size, a_data, TLAtomics.SWAP)._2,
+       M_XA_XOR  -> edge.Logical(a_source, a_address, a_size, a_data, TLAtomics.XOR) ._2,
+       M_XA_OR   -> edge.Logical(a_source, a_address, a_size, a_data, TLAtomics.OR)  ._2,
+diff --git a/src/main/scala/rocket/RocketCore.scala b/src/main/scala/rocket/RocketCore.scala
+index 65f8c7323..62c9486da 100644
+--- a/src/main/scala/rocket/RocketCore.scala
++++ b/src/main/scala/rocket/RocketCore.scala
+@@ -384,10 +384,10 @@ class Rocket(tile: RocketTile)(implicit p: Parameters) extends CoreModule()(p)
+   val ex_rs = for (i <- 0 until id_raddr.size)
+     yield Mux(ex_reg_rs_bypass(i), bypass_mux(ex_reg_rs_lsb(i)), Cat(ex_reg_rs_msb(i), ex_reg_rs_lsb(i)))
+   val ex_imm = ImmGen(ex_ctrl.sel_imm, ex_reg_inst)
+-  val ex_op1 = MuxLookup(ex_ctrl.sel_alu1, 0.S, Seq(
++  val ex_op1 = MuxLookup(ex_ctrl.sel_alu1, 0.S)(Seq(
+     A1_RS1 -> ex_rs(0).asSInt,
+     A1_PC -> ex_reg_pc.asSInt))
+-  val ex_op2 = MuxLookup(ex_ctrl.sel_alu2, 0.S, Seq(
++  val ex_op2 = MuxLookup(ex_ctrl.sel_alu2, 0.S)(Seq(
+     A2_RS2 -> ex_rs(1).asSInt,
+     A2_IMM -> ex_imm,
+     A2_SIZE -> Mux(ex_reg_rvc, 2.S, 4.S)))
+diff --git a/src/main/scala/rocket/ScratchpadSlavePort.scala b/src/main/scala/rocket/ScratchpadSlavePort.scala
+index c5b5632f5..998fe7e26 100644
+--- a/src/main/scala/rocket/ScratchpadSlavePort.scala
++++ b/src/main/scala/rocket/ScratchpadSlavePort.scala
+@@ -57,16 +57,16 @@ class ScratchpadSlavePort(address: Seq[AddressSet], coreDataBytes: Int, usingAto
+ 
+     def formCacheReq(a: TLBundleA) = {
+       val req = Wire(new HellaCacheReq)
+-      req.cmd := MuxLookup(a.opcode, M_XRD, Array(
++      req.cmd := MuxLookup(a.opcode, M_XRD)(Array(
+         TLMessages.PutFullData    -> M_XWR,
+         TLMessages.PutPartialData -> M_PWR,
+-        TLMessages.ArithmeticData -> MuxLookup(a.param, M_XRD, Array(
++        TLMessages.ArithmeticData -> MuxLookup(a.param, M_XRD)(Array(
+           TLAtomics.MIN           -> M_XA_MIN,
+           TLAtomics.MAX           -> M_XA_MAX,
+           TLAtomics.MINU          -> M_XA_MINU,
+           TLAtomics.MAXU          -> M_XA_MAXU,
+           TLAtomics.ADD           -> M_XA_ADD)),
+-        TLMessages.LogicalData    -> MuxLookup(a.param, M_XRD, Array(
++        TLMessages.LogicalData    -> MuxLookup(a.param, M_XRD)(Array(
+           TLAtomics.XOR           -> M_XA_XOR,
+           TLAtomics.OR            -> M_XA_OR,
+           TLAtomics.AND           -> M_XA_AND,
+diff --git a/src/main/scala/tilelink/AtomicAutomata.scala b/src/main/scala/tilelink/AtomicAutomata.scala
+index 3bf633db0..37211ba8f 100644
+--- a/src/main/scala/tilelink/AtomicAutomata.scala
++++ b/src/main/scala/tilelink/AtomicAutomata.scala
+@@ -178,7 +178,7 @@ class TLAtomicAutomata(logical: Boolean = true, arithmetic: Boolean = true, conc
+             when (en) {
+               r.fifoId := a_fifoId
+               r.bits   := in.a.bits
+-              r.lut    := MuxLookup(in.a.bits.param(1, 0), 0.U(4.W), Array(
++              r.lut    := MuxLookup(in.a.bits.param(1, 0), 0.U(4.W))(Array(
+                 TLAtomics.AND  -> 0x8.U,
+                 TLAtomics.OR   -> 0xe.U,
+                 TLAtomics.XOR  -> 0x6.U,
+diff --git a/src/main/scala/tilelink/Edges.scala b/src/main/scala/tilelink/Edges.scala
+index 2c555c03a..2fcb23fc2 100644
+--- a/src/main/scala/tilelink/Edges.scala
++++ b/src/main/scala/tilelink/Edges.scala
+@@ -4,7 +4,6 @@ package freechips.rocketchip.tilelink
+ 
+ import chisel3._
+ import chisel3.util._
+-import chisel3.internal.sourceinfo.SourceInfo
+ import chisel3.experimental.SourceInfo
+ import org.chipsalliance.cde.config.Parameters
+ import freechips.rocketchip.util._
+@@ -274,17 +273,17 @@ class TLEdge(
+ 
+   // Does the request need T permissions to be executed?
+   def needT(a: TLBundleA): Bool = {
+-    val acq_needT = MuxLookup(a.param, WireDefault(Bool(), DontCare), Array(
++    val acq_needT = MuxLookup(a.param, WireDefault(Bool(), DontCare))(Array(
+       TLPermissions.NtoB -> false.B,
+       TLPermissions.NtoT -> true.B,
+       TLPermissions.BtoT -> true.B))
+-    MuxLookup(a.opcode, WireDefault(Bool(), DontCare), Array(
++    MuxLookup(a.opcode, WireDefault(Bool(), DontCare))(Array(
+       TLMessages.PutFullData    -> true.B,
+       TLMessages.PutPartialData -> true.B,
+       TLMessages.ArithmeticData -> true.B,
+       TLMessages.LogicalData    -> true.B,
+       TLMessages.Get            -> false.B,
+-      TLMessages.Hint           -> MuxLookup(a.param, WireDefault(Bool(), DontCare), Array(
++      TLMessages.Hint           -> MuxLookup(a.param, WireDefault(Bool(), DontCare))(Array(
+         TLHints.PREFETCH_READ   -> false.B,
+         TLHints.PREFETCH_WRITE  -> true.B)),
+       TLMessages.AcquireBlock   -> acq_needT,
+diff --git a/src/main/scala/tilelink/Fragmenter.scala b/src/main/scala/tilelink/Fragmenter.scala
+index 0aace162b..f522cacbe 100644
+--- a/src/main/scala/tilelink/Fragmenter.scala
++++ b/src/main/scala/tilelink/Fragmenter.scala
+@@ -275,7 +275,7 @@ class TLFragmenter(val minSize: Int, val maxSize: Int, val alwaysMin: Boolean =
+         val maxLgHint        = Mux1H(find, maxLgHints)
+ 
+         val limit = if (alwaysMin) lgMinSize else
+-          MuxLookup(in_a.bits.opcode, lgMinSize, Array(
++          MuxLookup(in_a.bits.opcode, lgMinSize)(Array(
+             TLMessages.PutFullData    -> maxLgPutFull,
+             TLMessages.PutPartialData -> maxLgPutPartial,
+             TLMessages.ArithmeticData -> maxLgArithmetic,
+diff --git a/src/main/scala/tilelink/Fuzzer.scala b/src/main/scala/tilelink/Fuzzer.scala
+index 1b3ed7fee..878b4ae74 100644
+--- a/src/main/scala/tilelink/Fuzzer.scala
++++ b/src/main/scala/tilelink/Fuzzer.scala
+@@ -180,7 +180,7 @@ class TLFuzzer(
+     // Pick a specific message to try to send
+     val a_type_sel  = noiseMaker(3, inc, 0)
+ 
+-    val legal = legal_dest && MuxLookup(a_type_sel, glegal, Seq(
++    val legal = legal_dest && MuxLookup(a_type_sel, glegal)(Seq(
+       "b000".U -> glegal,
+       "b001".U -> (pflegal && !noModify.B),
+       "b010".U -> (pplegal && !noModify.B),
+@@ -188,7 +188,7 @@ class TLFuzzer(
+       "b100".U -> (llegal && !noModify.B),
+       "b101".U -> hlegal))
+ 
+-    val bits = MuxLookup(a_type_sel, gbits, Seq(
++    val bits = MuxLookup(a_type_sel, gbits)(Seq(
+       "b000".U -> gbits,
+       "b001".U -> pfbits,
+       "b010".U -> ppbits,
+diff --git a/src/main/scala/tilelink/Metadata.scala b/src/main/scala/tilelink/Metadata.scala
+index cbd0d8c50..7f4f2854c 100644
+--- a/src/main/scala/tilelink/Metadata.scala
++++ b/src/main/scala/tilelink/Metadata.scala
+@@ -81,7 +81,7 @@ class ClientMetadata extends Bundle {
+     import ClientStates._
+     val c = categorize(cmd)
+     //assert(c === rd || param === toT, "Client was expecting trunk permissions.")
+-    MuxLookup(Cat(c, param), Nothing, Seq(
++    MuxLookup(Cat(c, param), Nothing)(Seq(
+     //(effect param) -> (next)
+       Cat(rd, toB)   -> Branch,
+       Cat(rd, toT)   -> Trunk,
+@@ -137,7 +137,7 @@ class ClientMetadata extends Bundle {
+   private def cmdToPermCap(cmd: UInt): UInt = {
+     import MemoryOpCategories._
+     import TLPermissions._
+-    MuxLookup(cmd, toN, Seq(
++    MuxLookup(cmd, toN)(Seq(
+       M_FLUSH   -> toN,
+       M_PRODUCE -> toB,
+       M_CLEAN   -> toT))
+diff --git a/src/main/scala/util/RecordMap.scala b/src/main/scala/util/RecordMap.scala
+index 4dd6bc11a..fb2b22716 100644
+--- a/src/main/scala/util/RecordMap.scala
++++ b/src/main/scala/util/RecordMap.scala
+@@ -4,8 +4,8 @@ package freechips.rocketchip.util
+ 
+ import chisel3._
+ import scala.collection.immutable.ListMap
+-import chisel3.internal.requireIsChiselType
+-import chisel3.experimental.DataMirror.internal.chiselTypeClone
++import chisel3.experimental.requireIsChiselType
++import chisel3.reflect.DataMirror.internal.chiselTypeClone
+ 
+ final class RecordMap[T <: Data] (eltMap: ListMap[String, T])
+     extends Record {
+diff --git a/src/main/scala/util/TraceCoreInterface.scala b/src/main/scala/util/TraceCoreInterface.scala
+index 6f948e09d..fad9263a4 100644
+--- a/src/main/scala/util/TraceCoreInterface.scala
++++ b/src/main/scala/util/TraceCoreInterface.scala
+@@ -4,7 +4,6 @@
+ package freechips.rocketchip.util
+ 
+ import chisel3._
+-import chisel3.experimental.ChiselEnum
+ 
+ // Definitions for Trace core Interface defined in RISC-V Processor Trace Specification V1.0
+ object TraceItype extends ChiselEnum {
diff --git a/src/Top.scala b/src/Top.scala
new file mode 100644
index 00000000..a03d6a16
--- /dev/null
+++ b/src/Top.scala
@@ -0,0 +1,23 @@
+package ysyx
+
+import chisel3._
+import org.chipsalliance.cde.config.Parameters
+import freechips.rocketchip.system.DefaultConfig
+import freechips.rocketchip.diplomacy.LazyModule
+
+class ysyxSoCTop extends Module {
+  implicit val config: Parameters = new DefaultConfig
+
+  val io = IO(new Bundle { })
+  val dut = LazyModule(new ChipLinkSlave)
+  val mdut = Module(dut.module)
+  mdut.dontTouchPorts()
+  dut.slave.map(_ := DontCare)
+  dut.master_mmio.map(_ := DontCare)
+  dut.master_mem.map(_ := DontCare)
+  mdut.fpga_io.b2c := DontCare
+}
+
+object Elaborate extends App {
+  circt.stage.ChiselStage.emitSystemVerilogFile(new ysyxSoCTop, args)
+}
diff --git a/src/chiplink/Bundles.scala b/src/chiplink/Bundles.scala
index 48101661..874ee6bc 100644
--- a/src/chiplink/Bundles.scala
+++ b/src/chiplink/Bundles.scala
@@ -1,34 +1,34 @@
 // See LICENSE for license details.
 package sifive.blocks.devices.chiplink
 
-import Chisel.{defaultCompileOptions => _, _}
-import freechips.rocketchip.util.CompileOptions.NotStrictInferReset
-import freechips.rocketchip.util.{rightOR,GenericParameterizedBundle}
+import chisel3._
+import chisel3.util._
+import freechips.rocketchip.util.rightOR
 
-class WideDataLayerPortLane(params: ChipLinkParams) extends GenericParameterizedBundle(params) {
-  val clk  = Clock(OUTPUT)
-  val rst  = Bool(OUTPUT)
-  val send = Bool(OUTPUT)
-  val data = UInt(OUTPUT, width=params.dataBits)
+class WideDataLayerPortLane(val params: ChipLinkParams) extends Bundle {
+  val clk  = Output(Clock())
+  val rst  = Output(Bool())
+  val send = Output(Bool())
+  val data = Output(UInt(params.dataBits.W))
 }
 
-class WideDataLayerPort(params: ChipLinkParams) extends GenericParameterizedBundle(params) {
+class WideDataLayerPort(val params: ChipLinkParams) extends Bundle {
   val c2b = new WideDataLayerPortLane(params)
-  val b2c = new WideDataLayerPortLane(params).flip
+  val b2c = Flipped(new WideDataLayerPortLane(params))
 }
 
-class DataLayer(params: ChipLinkParams) extends GenericParameterizedBundle(params) {
-  val data = UInt(OUTPUT, width=params.dataBits)
-  val last = Bool(OUTPUT)
-  val beats = UInt(OUTPUT, width=params.xferBits + 1)
+class DataLayer(val params: ChipLinkParams) extends Bundle {
+  val data = Output(UInt(params.dataBits.W))
+  val last = Output(Bool())
+  val beats = Output(UInt((params.xferBits + 1).W))
 }
 
-class CreditBump(params: ChipLinkParams) extends GenericParameterizedBundle(params) {
-  val a = UInt(OUTPUT, width = params.creditBits)
-  val b = UInt(OUTPUT, width = params.creditBits)
-  val c = UInt(OUTPUT, width = params.creditBits)
-  val d = UInt(OUTPUT, width = params.creditBits)
-  val e = UInt(OUTPUT, width = params.creditBits)
+class CreditBump(val params: ChipLinkParams) extends Bundle {
+  val a = Output(UInt(params.creditBits.W))
+  val b = Output(UInt(params.creditBits.W))
+  val c = Output(UInt(params.creditBits.W))
+  val d = Output(UInt(params.creditBits.W))
+  val e = Output(UInt(params.creditBits.W))
   def X: Seq[UInt] = Seq(a, b, c, d, e)
 
   // saturating addition
@@ -36,7 +36,7 @@ class CreditBump(params: ChipLinkParams) extends GenericParameterizedBundle(para
     val out = Wire(new CreditBump(params))
     (out.X zip (X zip that.X)) foreach { case (o, (x, y)) =>
       val z = x +& y
-      o := Mux((z >> params.creditBits).orR, ~UInt(0, width=params.creditBits), z)
+      o := Mux((z >> params.creditBits).orR, ~0.U(params.creditBits.W), z)
     }
     out
   }
@@ -47,7 +47,7 @@ class CreditBump(params: ChipLinkParams) extends GenericParameterizedBundle(para
       val mask = rightOR(x) >> 1
       val msbOH = ~(~x | mask)
       val msb = OHToUInt(msbOH << 1, params.creditBits + 1) // 0 = 0, 1 = 1, 2 = 4, 3 = 8, ...
-      val pad = (msb | UInt(0, width=5))(4,0)
+      val pad = (msb | 0.U(5.W))(4,0)
       (pad, x & mask)
     }
     val (a_msb, a_rest) = msb(a)
@@ -57,8 +57,8 @@ class CreditBump(params: ChipLinkParams) extends GenericParameterizedBundle(para
     val (e_msb, e_rest) = msb(e)
     val header = Cat(
       e_msb, d_msb, c_msb, b_msb, a_msb,
-      UInt(0, width = 4), // padding
-      UInt(5, width = 3))
+      0.U(4.W), // padding
+      5.U(3.W))
 
     val out = Wire(new CreditBump(params))
     out.a := a_rest
@@ -72,7 +72,7 @@ class CreditBump(params: ChipLinkParams) extends GenericParameterizedBundle(para
 
 object CreditBump {
   def apply(params: ChipLinkParams, x: Int): CreditBump = {
-    val v = UInt(x, width = params.creditBits)
+    val v = x.U(params.creditBits.W)
     val out = Wire(new CreditBump(params))
     out.X.foreach { _ := v }
     out
@@ -80,8 +80,8 @@ object CreditBump {
 
   def apply(params: ChipLinkParams, header: UInt): CreditBump = {
     def convert(x: UInt) =
-      Mux(x > UInt(params.creditBits),
-          ~UInt(0, width = params.creditBits),
+      Mux(x > params.creditBits.U,
+          ~0.U(params.creditBits.W),
           UIntToOH(x, params.creditBits + 1) >> 1)
     val out = Wire(new CreditBump(params))
     out.a := convert(header(11,  7))
diff --git a/src/chiplink/CAM.scala b/src/chiplink/CAM.scala
index 366e3038..d37d2b78 100644
--- a/src/chiplink/CAM.scala
+++ b/src/chiplink/CAM.scala
@@ -25,14 +25,14 @@ class CAM(keys: Int, dataBits: Int) extends Module
   io.key := OHToUInt(free_sel, keys)
 
   io.alloc.ready := free.orR
-  when (io.alloc.fire()) { data.write(io.key, io.alloc.bits) }
+  when (io.alloc.fire) { data.write(io.key, io.alloc.bits) }
 
   // Support free in same cycle as alloc
-  val bypass = io.alloc.fire() && io.free.bits === io.key
+  val bypass = io.alloc.fire && io.free.bits === io.key
   io.data := Mux(bypass, io.alloc.bits, data(io.free.bits))
 
   // Update CAM usage
-  val clr = Mux(io.alloc.fire(), free_sel, 0.U)
+  val clr = Mux(io.alloc.fire, free_sel, 0.U)
   val set = Mux(io.free.valid, UIntToOH(io.free.bits), 0.U)
   free := (free & ~clr) | set
 }
diff --git a/src/chiplink/ChipLink.scala b/src/chiplink/ChipLink.scala
index a879ed7e..284791a7 100644
--- a/src/chiplink/ChipLink.scala
+++ b/src/chiplink/ChipLink.scala
@@ -1,9 +1,8 @@
 // See LICENSE for license details.
 package sifive.blocks.devices.chiplink
 
-import Chisel.{defaultCompileOptions => _, _}
-import freechips.rocketchip.util.CompileOptions.NotStrictInferReset
-import freechips.rocketchip.config.{Field, Parameters}
+import chisel3._
+import org.chipsalliance.cde.config.Parameters
 import freechips.rocketchip.diplomacy._
 import freechips.rocketchip.tilelink._
 import freechips.rocketchip.devices.tilelink._
@@ -82,14 +81,15 @@ class ChipLink(val params: ChipLinkParams)(implicit p: Parameters) extends LazyM
       TLC  = AddressSet.unify(tlc.flatMap(_.address)))
   }
 
-  lazy val module = new LazyModuleImp(this) {
+  lazy val module = new Impl
+  class Impl extends LazyModuleImp(this) {
     val io = IO(new Bundle {
-      val bypass = Bool(OUTPUT)
+      val bypass = Output(Bool())
       // When not syncTX, these drive the TX domain
-      val c2b_clk = Clock(INPUT)
-      val c2b_rst = Bool(INPUT)
+      val c2b_clk = Input(Clock())
+      val c2b_rst = Input(Bool())
       // If fpgaReset, we need a pulse that arrives before b2c_clk locks
-      val fpga_reset = if (params.fpgaReset) Some(Bool(INPUT)) else None
+      val fpga_reset = if (params.fpgaReset) Some(Input(Bool())) else None
     })
     val port = ioNode.bundle
 
@@ -165,7 +165,7 @@ class ChipLink(val params: ChipLinkParams)(implicit p: Parameters) extends LazyM
     io.fpga_reset match {
       case None =>
         // b2c.rst is actually synchronous to b2c.clk, so one flop is enough
-        rx.reset := AsyncResetReg(Bool(false), port.b2c.clk, port.b2c.rst, true, None)
+        rx.reset := AsyncResetReg(false.B, port.b2c.clk, port.b2c.rst, true, None)
       case Some(resetPulse) =>
         // For high performance, FPGA IO buffer registers must feed IO into D, not reset
         // However, FPGA registers also support an initial block to generate a reset pulse
@@ -201,6 +201,11 @@ class ChipLink(val params: ChipLinkParams)(implicit p: Parameters) extends LazyM
       tx.io.sc <> sinkC.io.q
       tx.io.sd <> sinkD.io.q
       tx.io.se <> sinkE.io.q
+      tx.io.a := DontCare
+      tx.io.b := DontCare
+      tx.io.c := DontCare
+      tx.io.d := DontCare
+      tx.io.e := DontCare
     } else {
       // Create the TX clock domain from input
       tx.clock := io.c2b_clk
@@ -225,7 +230,7 @@ class ChipLink(val params: ChipLinkParams)(implicit p: Parameters) extends LazyM
     sinkE.io.d_clSink := sourceD.io.e_clSink
 
     // Disable ChipLink while RX+TX are in reset
-    val do_bypass = ResetCatchAndSync(clock, rx.reset) || ResetCatchAndSync(clock, tx.reset)
+    val do_bypass = ResetCatchAndSync(clock, rx.reset.asBool) || ResetCatchAndSync(clock, tx.reset.asBool)
     sbypass.module.io.bypass := do_bypass
     mbypass.module.io.bypass := do_bypass
     io.bypass := do_bypass
diff --git a/src/chiplink/Parameters.scala b/src/chiplink/Parameters.scala
index 93add02a..cc677c29 100644
--- a/src/chiplink/Parameters.scala
+++ b/src/chiplink/Parameters.scala
@@ -1,9 +1,9 @@
 // See LICENSE for license details.
 package sifive.blocks.devices.chiplink
 
-import Chisel.{defaultCompileOptions => _, _}
-import freechips.rocketchip.util.CompileOptions.NotStrictInferReset
-import freechips.rocketchip.config.{Field, Parameters}
+import chisel3._
+import chisel3.util._
+import org.chipsalliance.cde.config.Field
 import freechips.rocketchip.diplomacy._
 import freechips.rocketchip.tilelink._
 import freechips.rocketchip.util.AsyncQueueParams
@@ -70,14 +70,14 @@ case class ChipLinkInfo(params: ChipLinkParams, edgeIn: TLEdge, edgeOut: TLEdge,
     val maxKey = m.keys.max
     val maxVal = m.values.max
     val valBits = log2Up(maxVal + 1)
-    val out = Wire(Vec(maxKey + 1, UInt(width = valBits)))
-    m.foreach { case (k, v) => out(k) := UInt(v, width = valBits) }
+    val out = Wire(Vec(maxKey + 1, UInt(valBits.W)))
+    m.foreach { case (k, v) => out(k) := v.U(valBits.W) }
     out
   }
 
   // Packet format; little-endian
   def encode(format: UInt, opcode: UInt, param: UInt, size: UInt, domain: UInt, source: UInt): UInt = {
-    def fmt(x: UInt, w: Int) = (x | UInt(0, width=w))(w-1, 0)
+    def fmt(x: UInt, w: Int) = (x | 0.U(w.W))(w-1, 0)
     Cat(
       fmt(source, 16),
       fmt(domain, 3),
@@ -99,12 +99,12 @@ case class ChipLinkInfo(params: ChipLinkParams, edgeIn: TLEdge, edgeOut: TLEdge,
 
   def size2beats(size: UInt): UInt = {
     val shift = log2Ceil(params.dataBytes)
-    Cat(UIntToOH(size|UInt(0, width=4), params.xferBits + 1) >> (shift + 1), size <= UInt(shift))
+    Cat(UIntToOH(size|0.U(4.W), params.xferBits + 1) >> (shift + 1), size <= shift.U)
   }
 
   def mask2beats(size: UInt): UInt = {
     val shift = log2Ceil(params.dataBytes*8)
-    Cat(UIntToOH(size|UInt(0, width=4), params.xferBits + 1) >> (shift + 1), size <= UInt(shift))
+    Cat(UIntToOH(size|0.U(4.W), params.xferBits + 1) >> (shift + 1), size <= shift.U)
   }
 
   def beats1(x: UInt, forceFormat: Option[UInt] = None): UInt = {
@@ -113,21 +113,21 @@ case class ChipLinkInfo(params: ChipLinkParams, edgeIn: TLEdge, edgeOut: TLEdge,
     val masks = mask2beats(size)
     val grant = opcode === TLMessages.Grant || opcode === TLMessages.GrantData
     val partial = opcode === TLMessages.PutPartialData
-    val a = Mux(opcode(2), UInt(0), beats) + UInt(2) + Mux(partial, masks, UInt(0))
-    val b = Mux(opcode(2), UInt(0), beats) + UInt(2) + Mux(partial, masks, UInt(0))
-    val c = Mux(opcode(0), beats, UInt(0)) + UInt(2)
-    val d = Mux(opcode(0), beats, UInt(0)) + grant.asUInt
-    val e = UInt(0)
-    val f = UInt(0)
-    Vec(a, b, c, d, e, f)(forceFormat.getOrElse(format))
+    val a = Mux(opcode(2), 0.U, beats) + 2.U + Mux(partial, masks, 0.U)
+    val b = Mux(opcode(2), 0.U, beats) + 2.U + Mux(partial, masks, 0.U)
+    val c = Mux(opcode(0), beats, 0.U) + 2.U
+    val d = Mux(opcode(0), beats, 0.U) + grant.asUInt
+    val e = 0.U
+    val f = 0.U
+    VecInit(a, b, c, d, e, f)(forceFormat.getOrElse(format))
   }
 
   def firstlast(x: DecoupledIO[UInt], forceFormat: Option[UInt] = None): (Bool, Bool) = {
-    val count = RegInit(UInt(0))
+    val count = RegInit(0.U)
     val beats = beats1(x.bits, forceFormat)
-    val first = count === UInt(0)
-    val last  = count === UInt(1) || (first && beats === UInt(0))
-    when (x.fire()) { count := Mux(first, beats, count - UInt(1)) }
+    val first = count === 0.U
+    val last  = count === 1.U || (first && beats === 0.U)
+    when (x.fire) { count := Mux(first, beats, count - 1.U) }
     (first, last)
   }
 
@@ -135,7 +135,7 @@ case class ChipLinkInfo(params: ChipLinkParams, edgeIn: TLEdge, edgeOut: TLEdge,
   def makeError(legal: Bool, address: UInt): UInt = {
     val alignBits = log2Ceil(errorDev.alignment)
     Cat(
-      Mux(legal, address, UInt(errorDev.base))(params.addressBits-1, alignBits),
+      Mux(legal, address, errorDev.base.U)(params.addressBits-1, alignBits),
       address(alignBits-1, 0))
   }
 }
diff --git a/src/chiplink/Partial.scala b/src/chiplink/Partial.scala
index c4b7991f..69fadfa0 100644
--- a/src/chiplink/Partial.scala
+++ b/src/chiplink/Partial.scala
@@ -1,18 +1,18 @@
 // See LICENSE for license details.
 package sifive.blocks.devices.chiplink
 
-import Chisel.{defaultCompileOptions => _, _}
-import freechips.rocketchip.util.CompileOptions.NotStrictInferReset
+import chisel3._
+import chisel3.util._
 import freechips.rocketchip.tilelink._
 import freechips.rocketchip.util._
 
 class ParitalExtractor[T <: TLDataChannel](gen: T) extends Module
 {
-  val io = new Bundle {
-    val last = Bool(INPUT)
-    val i = Decoupled(gen).flip
-    val o = Decoupled(gen)
-  }
+  val io = IO(new Bundle {
+    val last = Input(Bool())
+    val i = Flipped(Decoupled(chiselTypeOf(gen)))
+    val o = Decoupled(chiselTypeOf(gen))
+  })
 
   io.o <> io.i
 
@@ -26,40 +26,40 @@ class ParitalExtractor[T <: TLDataChannel](gen: T) extends Module
     case b: TLBundleB => (b.data, b.mask)
   }
 
-  val state  = RegInit(UInt(0, width=4)) // number of nibbles; [0,8]
-  val shift  = Reg(UInt(width=32))
+  val state  = RegInit(0.U(4.W)) // number of nibbles; [0,8]
+  val shift  = Reg(UInt(32.W))
   val enable = i_opcode === TLMessages.PutPartialData
-  val empty  = state === UInt(0)
+  val empty  = state === 0.U
 
   when (enable) {
     val wide = shift | (i_data << (state << 2))
-    o_data := Vec.tabulate(4) { i => wide(9*(i+1)-1, 9*i+1) } .asUInt
-    o_mask := Vec.tabulate(4) { i => wide(9*i) } .asUInt
+    o_data := VecInit.tabulate(4) { i => wide(9*(i+1)-1, 9*i+1) } .asUInt
+    o_mask := VecInit.tabulate(4) { i => wide(9*i) } .asUInt
 
     // Swallow beat if we have no nibbles
     when (empty) {
-      io.i.ready := Bool(true)
-      io.o.valid := Bool(false)
+      io.i.ready := true.B
+      io.o.valid := false.B
     }
 
     // Update the FSM
-    when (io.i.fire()) {
+    when (io.i.fire) {
       shift := Mux(empty, i_data, wide >> 36)
-      state := state - UInt(1)
-      when (empty)   { state := UInt(8) }
-      when (io.last) { state := UInt(0) }
+      state := state - 1.U
+      when (empty)   { state := 8.U }
+      when (io.last) { state := 0.U }
     }
   }
 }
 
 class PartialInjector[T <: TLDataChannel](gen: T) extends Module
 {
-  val io = new Bundle {
-    val i_last = Bool(INPUT)
-    val o_last = Bool(OUTPUT)
-    val i = Decoupled(gen).flip
-    val o = Decoupled(gen)
-  }
+  val io = IO(new Bundle {
+    val i_last = Input(Bool())
+    val o_last = Output(Bool())
+    val i = Flipped(Decoupled(chiselTypeOf(gen)))
+    val o = Decoupled(chiselTypeOf(gen))
+  })
 
   io.o <> io.i
 
@@ -73,12 +73,12 @@ class PartialInjector[T <: TLDataChannel](gen: T) extends Module
     case b: TLBundleB => b.data
   }
 
-  val state = RegInit(UInt(0, width=4)) // number of nibbles; [0,8]
-  val shift = RegInit(UInt(0, width=32))
+  val state = RegInit(0.U(4.W)) // number of nibbles; [0,8]
+  val shift = RegInit(0.U(32.W))
   val full  = state(3)
   val partial = i_opcode === TLMessages.PutPartialData
 
-  val last = RegInit(Bool(false))
+  val last = RegInit(false.B)
   io.o_last := Mux(partial, last, io.i_last)
 
   when (partial) {
@@ -90,16 +90,16 @@ class PartialInjector[T <: TLDataChannel](gen: T) extends Module
 
     // Inject a beat
     when ((io.i_last || full) && !last) {
-      io.i.ready := Bool(false)
+      io.i.ready := false.B
     }
 
     // Update the FSM
-    when (io.o.fire()) {
+    when (io.o.fire) {
       shift := wide >> 32
-      state := state + UInt(1)
+      state := state + 1.U
       when (full || last) {
-        state := UInt(0)
-        shift := UInt(0)
+        state := 0.U
+        shift := 0.U
       }
       last := io.i_last && !last
     }
diff --git a/src/chiplink/RX.scala b/src/chiplink/RX.scala
index 080112c6..70975bbe 100644
--- a/src/chiplink/RX.scala
+++ b/src/chiplink/RX.scala
@@ -1,49 +1,49 @@
 // See LICENSE for license details.
 package sifive.blocks.devices.chiplink
 
-import Chisel.{defaultCompileOptions => _, _}
-import freechips.rocketchip.util.CompileOptions.NotStrictInferReset
+import chisel3._
+import chisel3.util._
 import freechips.rocketchip.tilelink._
 import freechips.rocketchip.util._
 
 class RX(info: ChipLinkInfo) extends Module
 {
-  val io = new Bundle {
-    val b2c_send = Bool(INPUT)
-    val b2c_data = UInt(INPUT, info.params.dataBits)
-    val a = new AsyncBundle(UInt(width = info.params.dataBits), info.params.crossing)
-    val b = new AsyncBundle(UInt(width = info.params.dataBits), info.params.crossing)
-    val c = new AsyncBundle(UInt(width = info.params.dataBits), info.params.crossing)
-    val d = new AsyncBundle(UInt(width = info.params.dataBits), info.params.crossing)
-    val e = new AsyncBundle(UInt(width = info.params.dataBits), info.params.crossing)
+  val io = IO(new Bundle {
+    val b2c_send = Input(Bool())
+    val b2c_data = Input(UInt(info.params.dataBits.W))
+    val a = new AsyncBundle(UInt(info.params.dataBits.W), info.params.crossing)
+    val b = new AsyncBundle(UInt(info.params.dataBits.W), info.params.crossing)
+    val c = new AsyncBundle(UInt(info.params.dataBits.W), info.params.crossing)
+    val d = new AsyncBundle(UInt(info.params.dataBits.W), info.params.crossing)
+    val e = new AsyncBundle(UInt(info.params.dataBits.W), info.params.crossing)
     val rxc = new AsyncBundle(new CreditBump(info.params), AsyncQueueParams.singleton())
     val txc = new AsyncBundle(new CreditBump(info.params), AsyncQueueParams.singleton())
-  }
+  })
 
   // Immediately register our input data
   val b2c_data = RegNext(RegNext(io.b2c_data))
-  val b2c_send = RegNext(RegNext(io.b2c_send), Bool(false))
+  val b2c_send = RegNext(RegNext(io.b2c_send), false.B)
   // b2c_send is NOT cleared on the first RegNext because this module's reset has a flop on it
 
   // Fit b2c into the firstlast API
-  val beat = Wire(Decoupled(UInt(width = info.params.dataBits)))
+  val beat = Wire(Decoupled(UInt(info.params.dataBits.W)))
   beat.bits  := b2c_data
   beat.valid := b2c_send
-  beat.ready := Bool(true)
+  beat.ready := true.B
 
   // Select the correct HellaQueue for the request
   val (first, _) = info.firstlast(beat)
   val formatBits  = beat.bits(2, 0)
-  val formatValid = beat.fire() && first
+  val formatValid = beat.fire && first
   val format = Mux(formatValid, formatBits, RegEnable(formatBits, formatValid))
   val formatOH = UIntToOH(format)
 
   // Create the receiver buffers
-  val hqa = Module(new HellaQueue(info.params.Qdepth)(beat.bits))
-  val hqb = Module(new HellaQueue(info.params.Qdepth)(beat.bits))
-  val hqc = Module(new HellaQueue(info.params.Qdepth)(beat.bits))
-  val hqd = Module(new HellaQueue(info.params.Qdepth)(beat.bits))
-  val hqe = Module(new HellaQueue(info.params.Qdepth)(beat.bits))
+  val hqa = Module(new HellaQueue(info.params.Qdepth)(chisel3.chiselTypeOf(beat.bits)))
+  val hqb = Module(new HellaQueue(info.params.Qdepth)(chisel3.chiselTypeOf(beat.bits)))
+  val hqc = Module(new HellaQueue(info.params.Qdepth)(chisel3.chiselTypeOf(beat.bits)))
+  val hqd = Module(new HellaQueue(info.params.Qdepth)(chisel3.chiselTypeOf(beat.bits)))
+  val hqe = Module(new HellaQueue(info.params.Qdepth)(chisel3.chiselTypeOf(beat.bits)))
 
   // Use these to save some typing; function to prevent renaming
   private def hqX = Seq(hqa, hqb, hqc, hqd, hqe)
@@ -68,8 +68,8 @@ class RX(info: ChipLinkInfo) extends Module
   // Constantly transmit credit updates
   val txOut = Wire(Decoupled(new CreditBump(info.params)))
   val rxOut = Wire(Decoupled(new CreditBump(info.params)))
-  txOut.valid := Bool(true)
-  rxOut.valid := Bool(true)
+  txOut.valid := true.B
+  rxOut.valid := true.B
   txOut.bits := tx
   rxOut.bits := rx
   io.txc <> ToAsyncBundle(txOut, AsyncQueueParams.singleton())
@@ -78,7 +78,7 @@ class RX(info: ChipLinkInfo) extends Module
   // Generate new RX credits as the HellaQueues drain
   val rxInc = Wire(new CreditBump(info.params))
   (hqX zip rxInc.X) foreach { case (hq, inc) =>
-    inc := hq.io.deq.fire().asUInt
+    inc := hq.io.deq.fire.asUInt
   }
 
   // Generate new TX credits as we receive F-format messages
@@ -87,6 +87,6 @@ class RX(info: ChipLinkInfo) extends Module
   // As we hand-over credits, reset the counters
   tx := tx + txInc
   rx := rx + rxInc
-  when (txOut.fire()) { tx := txInc }
-  when (rxOut.fire()) { rx := rxInc }
+  when (txOut.fire) { tx := txInc }
+  when (rxOut.fire) { rx := rxInc }
 }
diff --git a/src/chiplink/SinkA.scala b/src/chiplink/SinkA.scala
index d629afcc..177ebc93 100644
--- a/src/chiplink/SinkA.scala
+++ b/src/chiplink/SinkA.scala
@@ -1,21 +1,21 @@
 // See LICENSE for license details.
 package sifive.blocks.devices.chiplink
 
-import Chisel.{defaultCompileOptions => _, _}
-import freechips.rocketchip.util.CompileOptions.NotStrictInferReset
+import chisel3._
+import chisel3.util._
 import freechips.rocketchip.tilelink._
 
 class SinkA(info: ChipLinkInfo) extends Module
 {
-  val io = new Bundle {
-    val a = Decoupled(new TLBundleA(info.edgeIn.bundle)).flip
+  val io = IO(new Bundle {
+    val a = Flipped(Decoupled(new TLBundleA(info.edgeIn.bundle)))
     val q = Decoupled(new DataLayer(info.params))
-  }
+  })
 
   // Map TileLink sources to ChipLink sources+domain
   val tl2cl = info.sourceMap
-  val source = info.mux(tl2cl.mapValues(_.source))
-  val domain = info.mux(tl2cl.mapValues(_.domain))
+  val source = info.mux(tl2cl.view.mapValues(_.source).toMap)
+  val domain = info.mux(tl2cl.view.mapValues(_.domain).toMap)
 
   // We need a Q because we stall the channel while serializing it's header
   val inject = Module(new PartialInjector(io.a.bits))
@@ -27,13 +27,13 @@ class SinkA(info: ChipLinkInfo) extends Module
   val a_partial = a.bits.opcode === TLMessages.PutPartialData
 
   // A simple FSM to generate the packet components
-  val state = RegInit(UInt(0, width = 2))
-  val s_header   = UInt(0, width = 2)
-  val s_address0 = UInt(1, width = 2)
-  val s_address1 = UInt(2, width = 2)
-  val s_data     = UInt(3, width = 2)
+  val state = RegInit(0.U(2.W))
+  val s_header   = 0.U(2.W)
+  val s_address0 = 1.U(2.W)
+  val s_address1 = 2.U(2.W)
+  val s_data     = 3.U(2.W)
 
-  when (io.q.fire()) {
+  when (io.q.fire) {
     switch (state) {
       is (s_header)   { state := s_address0 }
       is (s_address0) { state := s_address1 }
@@ -44,7 +44,7 @@ class SinkA(info: ChipLinkInfo) extends Module
 
   // Construct the header beat
   val header = info.encode(
-    format = UInt(0),
+    format = 0.U,
     opcode = a.bits.opcode,
     param  = a.bits.param,
     size   = a.bits.size,
@@ -60,7 +60,7 @@ class SinkA(info: ChipLinkInfo) extends Module
   a.ready := io.q.ready && isLastState
   io.q.valid := a.valid
   io.q.bits.last  := a_last && isLastState
-  io.q.bits.data  := Vec(header, address0, address1, a.bits.data)(state)
-  io.q.bits.beats := Mux(a_hasData, info.size2beats(a.bits.size), UInt(0)) + UInt(3) +
-                     Mux(a_partial, info.mask2beats(a.bits.size), UInt(0))
+  io.q.bits.data  := VecInit(header, address0, address1, a.bits.data)(state)
+  io.q.bits.beats := Mux(a_hasData, info.size2beats(a.bits.size), 0.U) + 3.U +
+                     Mux(a_partial, info.mask2beats(a.bits.size), 0.U)
 }
diff --git a/src/chiplink/SinkB.scala b/src/chiplink/SinkB.scala
index 38316160..d0ff52e2 100644
--- a/src/chiplink/SinkB.scala
+++ b/src/chiplink/SinkB.scala
@@ -1,16 +1,16 @@
 // See LICENSE for license details.
 package sifive.blocks.devices.chiplink
 
-import Chisel.{defaultCompileOptions => _, _}
-import freechips.rocketchip.util.CompileOptions.NotStrictInferReset
+import chisel3._
+import chisel3.util._
 import freechips.rocketchip.tilelink._
 
 class SinkB(info: ChipLinkInfo) extends Module
 {
-  val io = new Bundle {
-    val b = Decoupled(new TLBundleB(info.edgeOut.bundle)).flip
+  val io = IO(new Bundle {
+    val b = Flipped(Decoupled(new TLBundleB(info.edgeOut.bundle)))
     val q = Decoupled(new DataLayer(info.params))
-  }
+  })
 
   // We need a Q because we stall the channel while serializing it's header
   val inject = Module(new PartialInjector(io.b.bits))
@@ -22,13 +22,13 @@ class SinkB(info: ChipLinkInfo) extends Module
   val b_partial = b.bits.opcode === TLMessages.PutPartialData
 
   // A simple FSM to generate the packet components
-  val state = RegInit(UInt(0, width = 2))
-  val s_header   = UInt(0, width = 2)
-  val s_address0 = UInt(1, width = 2)
-  val s_address1 = UInt(2, width = 2)
-  val s_data     = UInt(3, width = 2)
+  val state = RegInit(0.U(2.W))
+  val s_header   = 0.U(2.W)
+  val s_address0 = 1.U(2.W)
+  val s_address1 = 2.U(2.W)
+  val s_data     = 3.U(2.W)
 
-  when (io.q.fire()) {
+  when (io.q.fire) {
     switch (state) {
       is (s_header)   { state := s_address0 }
       is (s_address0) { state := s_address1 }
@@ -39,14 +39,14 @@ class SinkB(info: ChipLinkInfo) extends Module
 
   // Construct the header beat
   val header = info.encode(
-    format = UInt(1),
+    format = 1.U,
     opcode = b.bits.opcode,
     param  = b.bits.param,
     size   = b.bits.size,
-    domain = UInt(0), // ChipLink only allows one remote cache, in domain 0
-    source = UInt(0))
+    domain = 0.U, // ChipLink only allows one remote cache, in domain 0
+    source = 0.U)
 
-  assert (!b.valid || b.bits.source === UInt(0))
+  assert (!b.valid || b.bits.source === 0.U)
 
   // Construct the address beats
   val address0 = b.bits.address
@@ -57,7 +57,7 @@ class SinkB(info: ChipLinkInfo) extends Module
   b.ready := io.q.ready && isLastState
   io.q.valid := b.valid
   io.q.bits.last  := b_last && isLastState
-  io.q.bits.data  := Vec(header, address0, address1, b.bits.data)(state)
-  io.q.bits.beats := Mux(b_hasData, info.size2beats(b.bits.size), UInt(0)) + UInt(3) +
-                     Mux(b_partial, info.mask2beats(b.bits.size), UInt(0))
+  io.q.bits.data  := VecInit(header, address0, address1, b.bits.data)(state)
+  io.q.bits.beats := Mux(b_hasData, info.size2beats(b.bits.size), 0.U) + 3.U +
+                     Mux(b_partial, info.mask2beats(b.bits.size), 0.U)
 }
diff --git a/src/chiplink/SinkC.scala b/src/chiplink/SinkC.scala
index 90b726ca..3b559f2a 100644
--- a/src/chiplink/SinkC.scala
+++ b/src/chiplink/SinkC.scala
@@ -1,21 +1,21 @@
 // See LICENSE for license details.
 package sifive.blocks.devices.chiplink
 
-import Chisel.{defaultCompileOptions => _, _}
-import freechips.rocketchip.util.CompileOptions.NotStrictInferReset
+import chisel3._
+import chisel3.util._
 import freechips.rocketchip.tilelink._
 
 class SinkC(info: ChipLinkInfo) extends Module
 {
-  val io = new Bundle {
-    val c = Decoupled(new TLBundleC(info.edgeIn.bundle)).flip
+  val io = IO(new Bundle {
+    val c = Flipped(Decoupled(new TLBundleC(info.edgeIn.bundle)))
     val q = Decoupled(new DataLayer(info.params))
-  }
+  })
 
   // Map TileLink sources to ChipLink sources+domain
   val tl2cl = info.sourceMap
-  val source = info.mux(tl2cl.mapValues(_.source))
-  val domain = info.mux(tl2cl.mapValues(_.domain))
+  val source = info.mux(tl2cl.view.mapValues(_.source).toMap)
+  val domain = info.mux(tl2cl.view.mapValues(_.domain).toMap)
 
   // We need a Q because we stall the channel while serializing it's header
   val c = Queue(io.c, 1, flow=true)
@@ -24,13 +24,13 @@ class SinkC(info: ChipLinkInfo) extends Module
   val c_release = c.bits.opcode === TLMessages.Release || c.bits.opcode === TLMessages.ReleaseData
 
   // A simple FSM to generate the packet components
-  val state = RegInit(UInt(0, width = 2))
-  val s_header   = UInt(0, width = 2)
-  val s_address0 = UInt(1, width = 2)
-  val s_address1 = UInt(2, width = 2)
-  val s_data     = UInt(3, width = 2)
+  val state = RegInit(0.U(2.W))
+  val s_header   = 0.U(2.W)
+  val s_address0 = 1.U(2.W)
+  val s_address1 = 2.U(2.W)
+  val s_data     = 3.U(2.W)
 
-  when (io.q.fire()) {
+  when (io.q.fire) {
     switch (state) {
       is (s_header)   { state := s_address0 }
       is (s_address0) { state := s_address1 }
@@ -41,14 +41,14 @@ class SinkC(info: ChipLinkInfo) extends Module
 
   // Construct the header beat
   val header = info.encode(
-    format = UInt(2),
+    format = 2.U,
     opcode = c.bits.opcode,
     param  = c.bits.param,
     size   = c.bits.size,
-    domain = UInt(0), // only caches (unordered) can release
-    source = Mux(c_release, source(c.bits.source), UInt(0)))
+    domain = 0.U, // only caches (unordered) can release
+    source = Mux(c_release, source(c.bits.source), 0.U))
 
-  assert (!c.valid || domain(c.bits.source) === UInt(0))
+  assert (!c.valid || domain(c.bits.source) === 0.U)
 
   // Construct the address beats
   val address0 = c.bits.address
@@ -59,6 +59,6 @@ class SinkC(info: ChipLinkInfo) extends Module
   c.ready := io.q.ready && isLastState
   io.q.valid := c.valid
   io.q.bits.last  := c_last && isLastState
-  io.q.bits.data  := Vec(header, address0, address1, c.bits.data)(state)
-  io.q.bits.beats := Mux(c_hasData, info.size2beats(c.bits.size), UInt(0)) + UInt(3)
+  io.q.bits.data  := VecInit(header, address0, address1, c.bits.data)(state)
+  io.q.bits.beats := Mux(c_hasData, info.size2beats(c.bits.size), 0.U) + 3.U
 }
diff --git a/src/chiplink/SinkD.scala b/src/chiplink/SinkD.scala
index 48f61959..c7bed704 100644
--- a/src/chiplink/SinkD.scala
+++ b/src/chiplink/SinkD.scala
@@ -1,26 +1,26 @@
 // See LICENSE for license details.
 package sifive.blocks.devices.chiplink
 
-import Chisel.{defaultCompileOptions => _, _}
-import freechips.rocketchip.util.CompileOptions.NotStrictInferReset
+import chisel3._
+import chisel3.util._
 import freechips.rocketchip.tilelink._
 
 class SinkD(info: ChipLinkInfo) extends Module
 {
-  val io = new Bundle {
-    val d = Decoupled(new TLBundleD(info.edgeOut.bundle)).flip
+  val io = IO(new Bundle {
+    val d = Flipped(Decoupled(new TLBundleD(info.edgeOut.bundle)))
     val q = Decoupled(new DataLayer(info.params))
-    val a_tlSource = Valid(UInt(width = info.params.sourceBits))
-    val a_clSource = UInt(INPUT, width = info.params.clSourceBits)
-    val c_tlSource = Valid(UInt(width = info.params.sourceBits))
-    val c_clSource = UInt(INPUT, width = info.params.clSourceBits)
-  }
+    val a_tlSource = Valid(UInt(info.params.sourceBits.W))
+    val a_clSource = Input(UInt(info.params.clSourceBits.W))
+    val c_tlSource = Valid(UInt(info.params.sourceBits.W))
+    val c_clSource = Input(UInt(info.params.clSourceBits.W))
+  })
 
   // The FSM states
-  val state = RegInit(UInt(0, width = 2))
-  val s_header   = UInt(0, width = 2)
-  val s_sink     = UInt(1, width = 2)
-  val s_data     = UInt(2, width = 2)
+  val state = RegInit(0.U(2.W))
+  val s_header   = 0.U(2.W)
+  val s_sink     = 1.U(2.W)
+  val s_data     = 2.U(2.W)
 
   // We need a Q because we stall the channel while serializing it's header
   val d = Queue(io.d, 1, flow=true)
@@ -28,7 +28,7 @@ class SinkD(info: ChipLinkInfo) extends Module
   val d_hasData = info.edgeOut.hasData(d.bits)
   val d_grant = d.bits.opcode === TLMessages.Grant || d.bits.opcode === TLMessages.GrantData
 
-  when (io.q.fire()) {
+  when (io.q.fire) {
     switch (state) {
       is (s_header)   { state := Mux(d_grant, s_sink, Mux(d_hasData, s_data, s_header)) }
       is (s_sink)     { state := Mux(d_hasData, s_data, s_header) }
@@ -38,14 +38,14 @@ class SinkD(info: ChipLinkInfo) extends Module
 
   // Release the TL source
   val relack = d.bits.opcode === TLMessages.ReleaseAck
-  io.a_tlSource.valid := io.q.fire() && state === s_header && !relack
+  io.a_tlSource.valid := io.q.fire && state === s_header && !relack
   io.a_tlSource.bits := d.bits.source
-  io.c_tlSource.valid := io.q.fire() && state === s_header &&  relack
+  io.c_tlSource.valid := io.q.fire && state === s_header &&  relack
   io.c_tlSource.bits := d.bits.source
 
   // Construct the header beat
   val header = info.encode(
-    format = UInt(3),
+    format = 3.U,
     opcode = d.bits.opcode,
     param  = Cat(d.bits.denied, d.bits.param),
     size   = d.bits.size,
@@ -56,6 +56,6 @@ class SinkD(info: ChipLinkInfo) extends Module
   d.ready := io.q.ready && isLastState
   io.q.valid := d.valid
   io.q.bits.last  := d_last && isLastState
-  io.q.bits.data  := Vec(header, d.bits.sink, d.bits.data)(state)
-  io.q.bits.beats := Mux(d_hasData, info.size2beats(d.bits.size), UInt(0)) + UInt(1) + d_grant.asUInt
+  io.q.bits.data  := VecInit(header, d.bits.sink, d.bits.data)(state)
+  io.q.bits.beats := Mux(d_hasData, info.size2beats(d.bits.size), 0.U) + 1.U + d_grant.asUInt
 }
diff --git a/src/chiplink/SinkE.scala b/src/chiplink/SinkE.scala
index ff8b228e..56dc1f45 100644
--- a/src/chiplink/SinkE.scala
+++ b/src/chiplink/SinkE.scala
@@ -1,34 +1,34 @@
 // See LICENSE for license details.
 package sifive.blocks.devices.chiplink
 
-import Chisel.{defaultCompileOptions => _, _}
-import freechips.rocketchip.util.CompileOptions.NotStrictInferReset
+import chisel3._
+import chisel3.util._
 import freechips.rocketchip.tilelink._
 
 class SinkE(info: ChipLinkInfo) extends Module
 {
-  val io = new Bundle {
-    val e = Decoupled(new TLBundleE(info.edgeIn.bundle)).flip
+  val io = IO(new Bundle {
+    val e = Flipped(Decoupled(new TLBundleE(info.edgeIn.bundle)))
     val q = Decoupled(new DataLayer(info.params))
     // Find the sink from D
-    val d_tlSink = Valid(UInt(width = info.params.sinkBits))
-    val d_clSink = UInt(INPUT, width = info.params.clSinkBits)
-  }
+    val d_tlSink = Valid(UInt(info.params.sinkBits.W))
+    val d_clSink = Input(UInt(info.params.clSinkBits.W))
+  })
 
-  io.d_tlSink.valid := io.e.fire()
+  io.d_tlSink.valid := io.e.fire
   io.d_tlSink.bits := io.e.bits.sink
 
   val header = info.encode(
-    format = UInt(4),
-    opcode = UInt(0),
-    param  = UInt(0),
-    size   = UInt(0),
-    domain = UInt(0),
+    format = 4.U,
+    opcode = 0.U,
+    param  = 0.U,
+    size   = 0.U,
+    domain = 0.U,
     source = io.d_clSink)
 
   io.e.ready := io.q.ready
   io.q.valid := io.e.valid
-  io.q.bits.last  := Bool(true)
+  io.q.bits.last  := true.B
   io.q.bits.data  := header
-  io.q.bits.beats := UInt(1)
+  io.q.bits.beats := 1.U
 }
diff --git a/src/chiplink/SourceA.scala b/src/chiplink/SourceA.scala
index 40672883..fb68c18e 100644
--- a/src/chiplink/SourceA.scala
+++ b/src/chiplink/SourceA.scala
@@ -1,20 +1,20 @@
 // See LICENSE for license details.
 package sifive.blocks.devices.chiplink
 
-import Chisel.{defaultCompileOptions => _, _}
-import freechips.rocketchip.util.CompileOptions.NotStrictInferReset
+import chisel3._
+import chisel3.util._
 import freechips.rocketchip.tilelink._
 import freechips.rocketchip.util._
 
 class SourceA(info: ChipLinkInfo) extends Module
 {
-  val io = new Bundle {
+  val io = IO(new Bundle {
     val a = Decoupled(new TLBundleA(info.edgeOut.bundle))
-    val q = Decoupled(UInt(width = info.params.dataBits)).flip
+    val q = Flipped(Decoupled(UInt(info.params.dataBits.W)))
     // Used by D to find the txn
-    val d_tlSource = Valid(UInt(width = info.params.sourceBits)).flip
-    val d_clSource = UInt(OUTPUT, width = info.params.clSourceBits)
-  }
+    val d_tlSource = Flipped(Valid(UInt(info.params.sourceBits.W)))
+    val d_clSource = Output(UInt(info.params.clSourceBits.W))
+  })
 
   // CAM of sources used for each domain
   val cams = Seq.fill(info.params.domains) {
@@ -22,11 +22,11 @@ class SourceA(info: ChipLinkInfo) extends Module
   }
 
   // A simple FSM to generate the packet components
-  val state = RegInit(UInt(0, width = 2))
-  val s_header   = UInt(0, width = 2)
-  val s_address0 = UInt(1, width = 2)
-  val s_address1 = UInt(2, width = 2)
-  val s_data     = UInt(3, width = 2)
+  val state = RegInit(0.U(2.W))
+  val s_header   = 0.U(2.W)
+  val s_address0 = 1.U(2.W)
+  val s_address1 = 2.U(2.W)
+  val s_data     = 3.U(2.W)
 
   private def hold(key: UInt)(data: UInt) = {
     val enable = state === key
@@ -41,11 +41,11 @@ class SourceA(info: ChipLinkInfo) extends Module
   val q_address0 = hold(s_address0)(io.q.bits)
   val q_address1 = hold(s_address1)(io.q.bits)
 
-  val (_, q_last) = info.firstlast(io.q, Some(UInt(0)))
+  val (_, q_last) = info.firstlast(io.q, Some(0.U))
   val q_hasData = !q_opcode(2)
-  val a_first = RegEnable(state =/= s_data, io.q.fire())
+  val a_first = RegEnable(state =/= s_data, io.q.fire)
 
-  when (io.q.fire()) {
+  when (io.q.fire) {
     switch (state) {
       is (s_header)   { state := s_address0 }
       is (s_address0) { state := s_address1 }
@@ -61,14 +61,14 @@ class SourceA(info: ChipLinkInfo) extends Module
   val exists = info.edgeOut.manager.containsSafe(q_address)
   private def writeable(m: TLManagerParameters): Boolean = if (m.supportsAcquireB) m.supportsAcquireT else m.supportsPutFull
   private def acquireable(m: TLManagerParameters): Boolean = m.supportsAcquireB || m.supportsAcquireT
-  private def toBool(x: Boolean) = Bool(x)
+  private def toBool(x: Boolean) = x.B
   val writeOk = info.edgeOut.manager.fastProperty(q_address, writeable, toBool)
   val acquireOk = info.edgeOut.manager.fastProperty(q_address, acquireable, toBool)
   val q_legal = exists && (!q_write || writeOk) && (!q_acq || acquireOk)
 
   // Look for an available source in the correct domain
-  val source_ok = Vec(cams.map(_.io.alloc.ready))(q_domain)
-  val source    = Vec(cams.map(_.io.key))(q_domain) holdUnless a_first
+  val source_ok = VecInit(cams.map(_.io.alloc.ready))(q_domain)
+  val source    = VecInit(cams.map(_.io.key))(q_domain) holdUnless a_first
   val a_sel = UIntToOH(q_domain)
 
   // Feed our preliminary A channel via the Partial Extractor FSM
@@ -84,7 +84,7 @@ class SourceA(info: ChipLinkInfo) extends Module
   a.bits.address := info.makeError(q_legal, q_address)
   a.bits.mask    := MaskGen(q_address0, q_size, info.params.dataBytes)
   a.bits.data    := io.q.bits
-  a.bits.corrupt := Bool(false)
+  a.bits.corrupt := false.B
 
   val stall = a_first && !source_ok
   val xmit = q_last || state === s_data
@@ -98,7 +98,7 @@ class SourceA(info: ChipLinkInfo) extends Module
   // Free the CAM entries
   val d_clDomain = io.d_tlSource.bits >> log2Ceil(info.params.sourcesPerDomain)
   val d_sel = UIntToOH(d_clDomain)
-  io.d_clSource := Vec(cams.map(_.io.data))(d_clDomain)
+  io.d_clSource := VecInit(cams.map(_.io.data))(d_clDomain)
   (cams zip d_sel.asBools) foreach { case (cam, sel) =>
     cam.io.free.bits  := io.d_tlSource.bits
     cam.io.free.valid := io.d_tlSource.valid && sel
diff --git a/src/chiplink/SourceB.scala b/src/chiplink/SourceB.scala
index 60121056..ac7c2d29 100644
--- a/src/chiplink/SourceB.scala
+++ b/src/chiplink/SourceB.scala
@@ -1,27 +1,27 @@
 // See LICENSE for license details.
 package sifive.blocks.devices.chiplink
 
-import Chisel.{defaultCompileOptions => _, _}
-import freechips.rocketchip.util.CompileOptions.NotStrictInferReset
+import chisel3._
+import chisel3.util._
 import freechips.rocketchip.tilelink._
 import freechips.rocketchip.util._
 
 class SourceB(info: ChipLinkInfo) extends Module
 {
-  val io = new Bundle {
+  val io = IO(new Bundle {
     val b = Decoupled(new TLBundleB(info.edgeIn.bundle))
-    val q = Decoupled(UInt(width = info.params.dataBits)).flip
-  }
+    val q = Flipped(Decoupled(UInt(info.params.dataBits.W)))
+  })
 
   // Find the optional cache (at most one)
   val cache = info.edgeIn.client.clients.filter(_.supports.probe).headOption
 
   // A simple FSM to generate the packet components
-  val state = RegInit(UInt(0, width = 2))
-  val s_header   = UInt(0, width = 2)
-  val s_address0 = UInt(1, width = 2)
-  val s_address1 = UInt(2, width = 2)
-  val s_data     = UInt(3, width = 2)
+  val state = RegInit(0.U(2.W))
+  val s_header   = 0.U(2.W)
+  val s_address0 = 1.U(2.W)
+  val s_address1 = 2.U(2.W)
+  val s_data     = 3.U(2.W)
 
   private def hold(key: UInt)(data: UInt) = {
     val enable = state === key
@@ -36,11 +36,11 @@ class SourceB(info: ChipLinkInfo) extends Module
   val q_address0 = hold(s_address0)(io.q.bits)
   val q_address1 = hold(s_address1)(io.q.bits)
 
-  val (_, q_last) = info.firstlast(io.q, Some(UInt(1)))
+  val (_, q_last) = info.firstlast(io.q, Some(1.U))
   val q_hasData = !q_opcode(2)
-  val b_first = RegEnable(state =/= s_data, io.q.fire())
+  val b_first = RegEnable(state =/= s_data, io.q.fire)
 
-  when (io.q.fire()) {
+  when (io.q.fire) {
     switch (state) {
       is (s_header)   { state := s_address0 }
       is (s_address0) { state := s_address1 }
@@ -58,11 +58,11 @@ class SourceB(info: ChipLinkInfo) extends Module
   b.bits.opcode  := q_opcode
   b.bits.param   := q_param
   b.bits.size    := q_size
-  b.bits.source  := UInt(cache.map(_.sourceId.start).getOrElse(0))
+  b.bits.source  := cache.map(_.sourceId.start).getOrElse(0).U
   b.bits.address := Cat(q_address1, q_address0)
   b.bits.mask    := MaskGen(q_address0, q_size, info.params.dataBytes)
   b.bits.data    := io.q.bits
-  b.bits.corrupt := Bool(false)
+  b.bits.corrupt := false.B
 
   val xmit = q_last || state === s_data
   b.valid := io.q.valid &&  xmit
diff --git a/src/chiplink/SourceC.scala b/src/chiplink/SourceC.scala
index aae5b34e..d4f2919c 100644
--- a/src/chiplink/SourceC.scala
+++ b/src/chiplink/SourceC.scala
@@ -1,30 +1,30 @@
 // See LICENSE for license details.
 package sifive.blocks.devices.chiplink
 
-import Chisel.{defaultCompileOptions => _, _}
-import freechips.rocketchip.util.CompileOptions.NotStrictInferReset
+import chisel3._
+import chisel3.util._
 import freechips.rocketchip.tilelink._
 import freechips.rocketchip.util._
 
 class SourceC(info: ChipLinkInfo) extends Module
 {
-  val io = new Bundle {
+  val io = IO(new Bundle {
     val c = Decoupled(new TLBundleC(info.edgeOut.bundle))
-    val q = Decoupled(UInt(width = info.params.dataBits)).flip
+    val q = Flipped(Decoupled(UInt(info.params.dataBits.W)))
     // Used by D to find the txn
-    val d_tlSource = Valid(UInt(width = info.params.sourceBits)).flip
-    val d_clSource = UInt(OUTPUT, width = info.params.clSourceBits)
-  }
+    val d_tlSource = Flipped(Valid(UInt(info.params.sourceBits.W)))
+    val d_clSource = Output(UInt(info.params.clSourceBits.W))
+  })
 
   // CAM of sources used for release
   val cam = Module(new CAM(info.params.sourcesPerDomain, info.params.clSourceBits))
 
   // A simple FSM to generate the packet components
-  val state = RegInit(UInt(0, width = 2))
-  val s_header   = UInt(0, width = 2)
-  val s_address0 = UInt(1, width = 2)
-  val s_address1 = UInt(2, width = 2)
-  val s_data     = UInt(3, width = 2)
+  val state = RegInit(0.U(2.W))
+  val s_header   = 0.U(2.W)
+  val s_address0 = 1.U(2.W)
+  val s_address1 = 2.U(2.W)
+  val s_data     = 3.U(2.W)
 
   private def hold(key: UInt)(data: UInt) = {
     val enable = state === key
@@ -39,11 +39,11 @@ class SourceC(info: ChipLinkInfo) extends Module
   val q_address0 = hold(s_address0)(io.q.bits)
   val q_address1 = hold(s_address1)(io.q.bits)
 
-  val (_, q_last) = info.firstlast(io.q, Some(UInt(2)))
+  val (_, q_last) = info.firstlast(io.q, Some(2.U))
   val q_hasData = q_opcode(0)
-  val c_first = RegEnable(state =/= s_data, io.q.fire())
+  val c_first = RegEnable(state =/= s_data, io.q.fire)
 
-  when (io.q.fire()) {
+  when (io.q.fire) {
     switch (state) {
       is (s_header)   { state := s_address0 }
       is (s_address0) { state := s_address1 }
@@ -57,7 +57,7 @@ class SourceC(info: ChipLinkInfo) extends Module
   val exists = info.edgeOut.manager.containsSafe(q_address)
   private def writeable(m: TLManagerParameters): Boolean = if (m.supportsAcquireB) m.supportsAcquireT else m.supportsPutFull
   private def acquireable(m: TLManagerParameters): Boolean = m.supportsAcquireB || m.supportsAcquireT
-  private def toBool(x: Boolean) = Bool(x)
+  private def toBool(x: Boolean) = x.B
   val writeOk = info.edgeOut.manager.fastProperty(q_address, writeable, toBool)
   val acquireOk = info.edgeOut.manager.fastProperty(q_address, acquireable, toBool)
   val q_legal = exists && (!q_hasData || writeOk) && acquireOk
@@ -70,10 +70,10 @@ class SourceC(info: ChipLinkInfo) extends Module
   io.c.bits.opcode  := q_opcode
   io.c.bits.param   := q_param
   io.c.bits.size    := q_size
-  io.c.bits.source  := Mux(q_release, source, UInt(0)) // always domain 0
+  io.c.bits.source  := Mux(q_release, source, 0.U) // always domain 0
   io.c.bits.address := info.makeError(q_legal, q_address)
   io.c.bits.data    := io.q.bits
-  io.c.bits.corrupt := Bool(false)
+  io.c.bits.corrupt := false.B
 
   val stall = c_first && !source_ok
   val xmit = q_last || state === s_data
diff --git a/src/chiplink/SourceD.scala b/src/chiplink/SourceD.scala
index 5723347f..903e343e 100644
--- a/src/chiplink/SourceD.scala
+++ b/src/chiplink/SourceD.scala
@@ -1,20 +1,20 @@
 // See LICENSE for license details.
 package sifive.blocks.devices.chiplink
 
-import Chisel.{defaultCompileOptions => _, _}
-import freechips.rocketchip.util.CompileOptions.NotStrictInferReset
+import chisel3._
+import chisel3.util._
 import freechips.rocketchip.tilelink._
 import freechips.rocketchip.util._
 
 class SourceD(info: ChipLinkInfo) extends Module
 {
-  val io = new Bundle {
+  val io = IO(new Bundle {
     val d = Decoupled(new TLBundleD(info.edgeIn.bundle))
-    val q = Decoupled(UInt(width = info.params.dataBits)).flip
+    val q = Flipped(Decoupled(UInt(info.params.dataBits.W)))
     // Used by E to find the txn
-    val e_tlSink = Valid(UInt(width = info.params.sinkBits)).flip
-    val e_clSink = UInt(OUTPUT, width = info.params.clSinkBits)
-  }
+    val e_tlSink = Flipped(Valid(UInt(info.params.sinkBits.W)))
+    val e_clSink = Output(UInt(info.params.clSinkBits.W))
+  })
 
   // We need a sink id CAM
   val cam = Module(new CAM(info.params.sinks, info.params.clSinkBits))
@@ -27,10 +27,10 @@ class SourceD(info: ChipLinkInfo) extends Module
   }
 
   // The FSM states
-  val state = RegInit(UInt(0, width = 2))
-  val s_header   = UInt(0, width = 2)
-  val s_sink     = UInt(1, width = 2)
-  val s_data     = UInt(2, width = 2)
+  val state = RegInit(0.U(2.W))
+  val s_header   = 0.U(2.W)
+  val s_sink     = 1.U(2.W)
+  val s_data     = 2.U(2.W)
 
   private def hold(key: UInt)(data: UInt) = {
     val enable = state === key
@@ -45,11 +45,11 @@ class SourceD(info: ChipLinkInfo) extends Module
   val q_sink = hold(s_sink)(io.q.bits(15, 0))
 
   val q_grant = q_opcode === TLMessages.Grant || q_opcode === TLMessages.GrantData
-  val (_, q_last) = info.firstlast(io.q, Some(UInt(3)))
-  val d_first = RegEnable(state =/= s_data, io.q.fire())
+  val (_, q_last) = info.firstlast(io.q, Some(3.U))
+  val d_first = RegEnable(state =/= s_data, io.q.fire)
   val s_maybe_data = Mux(q_last, s_header, s_data)
 
-  when (io.q.fire()) {
+  when (io.q.fire) {
     switch (state) {
       is (s_header)   { state := Mux(q_grant, s_sink, s_maybe_data) }
       is (s_sink)     { state := s_maybe_data }
@@ -66,8 +66,8 @@ class SourceD(info: ChipLinkInfo) extends Module
   io.d.bits.opcode  := q_opcode
   io.d.bits.param   := q_param(1,0)
   io.d.bits.size    := q_size
-  io.d.bits.source  := Vec(muxes.map { m => m(q_source) })(q_domain)
-  io.d.bits.sink    := Mux(q_grant, sink, UInt(0))
+  io.d.bits.source  := VecInit(muxes.map { m => m(q_source) })(q_domain)
+  io.d.bits.sink    := Mux(q_grant, sink, 0.U)
   io.d.bits.denied  := q_param >> 2
   io.d.bits.data    := io.q.bits
   io.d.bits.corrupt := io.d.bits.denied && info.edgeIn.hasData(io.d.bits)
diff --git a/src/chiplink/SourceE.scala b/src/chiplink/SourceE.scala
index ac5a245f..553fa608 100644
--- a/src/chiplink/SourceE.scala
+++ b/src/chiplink/SourceE.scala
@@ -1,17 +1,17 @@
 // See LICENSE for license details.
 package sifive.blocks.devices.chiplink
 
-import Chisel.{defaultCompileOptions => _, _}
-import freechips.rocketchip.util.CompileOptions.NotStrictInferReset
+import chisel3._
+import chisel3.util._
 import freechips.rocketchip.tilelink._
 import freechips.rocketchip.util._
 
 class SourceE(info: ChipLinkInfo) extends Module
 {
-  val io = new Bundle {
+  val io = IO(new Bundle {
     val e = Decoupled(new TLBundleE(info.edgeOut.bundle))
-    val q = Decoupled(UInt(width = info.params.dataBits)).flip
-  }
+    val q = Flipped(Decoupled(UInt(info.params.dataBits.W)))
+  })
 
   // Extract header fields
   val Seq(_, _, _, _, _, q_sink) = info.decode(io.q.bits)
diff --git a/src/chiplink/StuckSnooper.scala b/src/chiplink/StuckSnooper.scala
index a364a9b3..2bc66543 100644
--- a/src/chiplink/StuckSnooper.scala
+++ b/src/chiplink/StuckSnooper.scala
@@ -2,9 +2,8 @@
 
 package sifive.blocks.devices.chiplink
 
-import Chisel.{defaultCompileOptions => _, _}
-import freechips.rocketchip.util.CompileOptions.NotStrictInferReset
-import freechips.rocketchip.config.{Field, Parameters}
+import chisel3._
+import org.chipsalliance.cde.config.Parameters
 import freechips.rocketchip.diplomacy._
 import freechips.rocketchip.tilelink._
 import freechips.rocketchip.util._
@@ -27,10 +26,11 @@ class StuckSnooper(uFn: Seq[TLClientPortParameters] => TLClientPortParameters)(i
 {
   val node = new StuckSnooperNode(uFn)
 
-  lazy val module = new LazyModuleImp(this) {
+  lazy val module = new Impl
+  class Impl extends LazyModuleImp(this) {
     val io = IO(new Bundle {
-      val bypass = Bool(INPUT)
-      val pending = Bool(OUTPUT)
+      val bypass = Input(Bool())
+      val pending = Output(Bool())
     })
 
     val Seq((in0, edgeIn0), (in1, edgeIn1)) = node.in
@@ -42,13 +42,13 @@ class StuckSnooper(uFn: Seq[TLClientPortParameters] => TLClientPortParameters)(i
     val (flight, next_flight) = edgeOut.inFlight(out)
 
     io.pending := (flight > 0.U)
-    when (next_flight === UInt(0)) { bypass := io.bypass }
+    when (next_flight === 0.U) { bypass := io.bypass }
     val stall = (bypass =/= io.bypass) && edgeOut.first(out.a)
 
     in0.a.ready := !stall && out.a.ready &&  bypass
     in1.a.ready := !stall && out.a.ready && !bypass
     out.a.valid := !stall && Mux(bypass, in0.a.valid, in1.a.valid)
-    def castA(x: TLBundleA) = { val ret = Wire(out.a.bits); ret <> x; ret }
+    def castA(x: TLBundleA) = { val ret = Wire(chiselTypeOf(out.a.bits)); ret <> x; ret }
     out.a.bits := Mux(bypass, castA(in0.a.bits), castA(in1.a.bits))
 
     out.d.ready := Mux(bypass, in0.d.ready, in1.d.ready)
@@ -59,7 +59,7 @@ class StuckSnooper(uFn: Seq[TLClientPortParameters] => TLClientPortParameters)(i
 
     //Enable probes to in1 only after it issues an acquire
     val divertprobes = RegInit(true.B)
-    divertprobes := divertprobes && ~(in1.a.fire() && (in1.a.bits.opcode === TLMessages.AcquireBlock || in1.a.bits.opcode === TLMessages.AcquirePerm))
+    divertprobes := divertprobes && ~(in1.a.fire && (in1.a.bits.opcode === TLMessages.AcquireBlock || in1.a.bits.opcode === TLMessages.AcquirePerm))
     val bypass_c = Wire(Bool()) 
     bypass_c := bypass || divertprobes
 
@@ -73,26 +73,26 @@ class StuckSnooper(uFn: Seq[TLClientPortParameters] => TLClientPortParameters)(i
       in0.c.ready := out.c.ready &&  bypass_c
       in1.c.ready := out.c.ready && !bypass_c
       out.c.valid := Mux(bypass_c, in0.c.valid, in1.c.valid)
-      def castC(x: TLBundleC) = { val ret = Wire(out.c.bits); ret <> x; ret }
+      def castC(x: TLBundleC) = { val ret = Wire(chiselTypeOf(out.c.bits)); ret <> x; ret }
       out.c.bits := Mux(bypass_c, castC(in0.c.bits), castC(in1.c.bits))
 
       in0.e.ready := out.e.ready &&  bypass_c
       in1.e.ready := out.e.ready && !bypass_c
       out.e.valid := Mux(bypass_c, in0.e.valid, in1.e.valid)
-      def castE(x: TLBundleE) = { val ret = Wire(out.e.bits); ret <> x; ret }
+      def castE(x: TLBundleE) = { val ret = Wire(chiselTypeOf(out.e.bits)); ret <> x; ret }
       out.e.bits := Mux(bypass_c, castE(in0.e.bits), castE(in1.e.bits))
     } else {
-      in0.b.valid := Bool(false)
-      in0.c.ready := Bool(true)
-      in0.e.ready := Bool(true)
+      in0.b.valid := false.B
+      in0.c.ready := true.B
+      in0.e.ready := true.B
 
-      in1.b.valid := Bool(false)
-      in1.c.ready := Bool(true)
-      in1.e.ready := Bool(true)
+      in1.b.valid := false.B
+      in1.c.ready := true.B
+      in1.e.ready := true.B
 
-      out.b.ready := Bool(true)
-      out.c.valid := Bool(false)
-      out.e.valid := Bool(false)
+      out.b.ready := true.B
+      out.c.valid := false.B
+      out.e.valid := false.B
     }
   }
 }
@@ -112,9 +112,10 @@ class TLStuckSnooperTester(txns: Int)(implicit p: Parameters) extends LazyModule
   ram.node := TLFragmenter(4, 16) := mux.node
   // how to test probe + release?
 
-  lazy val module = new LazyModuleImp(this) with UnitTestModule {
+  lazy val module = new Impl
+  class Impl extends LazyModuleImp(this) with UnitTestModule {
     io.finished := fuzz1.module.io.finished && fuzz2.module.io.finished
-    mux.module.io.bypass := LFSR64(Bool(true))(0)
+    mux.module.io.bypass := LFSR64(true.B)(0)
   }
 }
 
diff --git a/src/chiplink/TX.scala b/src/chiplink/TX.scala
index 7b83479f..b4a8492f 100644
--- a/src/chiplink/TX.scala
+++ b/src/chiplink/TX.scala
@@ -1,31 +1,31 @@
 // See LICENSE for license details.
 package sifive.blocks.devices.chiplink
 
-import Chisel.{defaultCompileOptions => _, _}
-import freechips.rocketchip.util.CompileOptions.NotStrictInferReset
+import chisel3._
+import chisel3.util._
 import freechips.rocketchip.tilelink._
 import freechips.rocketchip.util._
 
 class TX(info: ChipLinkInfo) extends Module
 {
-  val io = new Bundle {
-    val c2b_clk  = Clock(OUTPUT)
-    val c2b_rst  = Bool(OUTPUT)
-    val c2b_send = Bool(OUTPUT)
-    val c2b_data = UInt(OUTPUT, info.params.dataBits)
-    val a = new AsyncBundle(new DataLayer(info.params), info.params.crossing).flip
-    val b = new AsyncBundle(new DataLayer(info.params), info.params.crossing).flip
-    val c = new AsyncBundle(new DataLayer(info.params), info.params.crossing).flip
-    val d = new AsyncBundle(new DataLayer(info.params), info.params.crossing).flip
-    val e = new AsyncBundle(new DataLayer(info.params), info.params.crossing).flip
-    val sa = DecoupledIO(new DataLayer(info.params)).flip
-    val sb = DecoupledIO(new DataLayer(info.params)).flip
-    val sc = DecoupledIO(new DataLayer(info.params)).flip
-    val sd = DecoupledIO(new DataLayer(info.params)).flip
-    val se = DecoupledIO(new DataLayer(info.params)).flip
-    val rxc = new AsyncBundle(new CreditBump(info.params), AsyncQueueParams.singleton()).flip
-    val txc = new AsyncBundle(new CreditBump(info.params), AsyncQueueParams.singleton()).flip
-  }
+  val io = IO(new Bundle {
+    val c2b_clk  = Output(Clock())
+    val c2b_rst  = Output(Bool())
+    val c2b_send = Output(Bool())
+    val c2b_data = Output(UInt(info.params.dataBits.W))
+    val a = Flipped(new AsyncBundle(new DataLayer(info.params), info.params.crossing))
+    val b = Flipped(new AsyncBundle(new DataLayer(info.params), info.params.crossing))
+    val c = Flipped(new AsyncBundle(new DataLayer(info.params), info.params.crossing))
+    val d = Flipped(new AsyncBundle(new DataLayer(info.params), info.params.crossing))
+    val e = Flipped(new AsyncBundle(new DataLayer(info.params), info.params.crossing))
+    val sa = Flipped(DecoupledIO(new DataLayer(info.params)))
+    val sb = Flipped(DecoupledIO(new DataLayer(info.params)))
+    val sc = Flipped(DecoupledIO(new DataLayer(info.params)))
+    val sd = Flipped(DecoupledIO(new DataLayer(info.params)))
+    val se = Flipped(DecoupledIO(new DataLayer(info.params)))
+    val rxc = Flipped(new AsyncBundle(new CreditBump(info.params), AsyncQueueParams.singleton()))
+    val txc = Flipped(new AsyncBundle(new CreditBump(info.params), AsyncQueueParams.singleton()))
+  })
 
   // Currently available credits
   val rx = RegInit(CreditBump(info.params, 0))
@@ -34,11 +34,16 @@ class TX(info: ChipLinkInfo) extends Module
   // Constantly pull credits from RX
   val rxInc = FromAsyncBundle(io.rxc)
   val txInc = FromAsyncBundle(io.txc)
-  rxInc.ready := Bool(true)
-  txInc.ready := Bool(true)
+  rxInc.ready := true.B
+  txInc.ready := true.B
 
   // Cross the requests (if necessary)
   val sync = info.params.syncTX
+  io.a := DontCare
+  io.b := DontCare
+  io.c := DontCare
+  io.d := DontCare
+  io.e := DontCare
   val qa = if (sync) ShiftQueue(io.sa, 2) else FromAsyncBundle(io.a)
   val qb = if (sync) ShiftQueue(io.sb, 2) else FromAsyncBundle(io.b)
   val qc = if (sync) ShiftQueue(io.sc, 2) else FromAsyncBundle(io.c)
@@ -48,10 +53,10 @@ class TX(info: ChipLinkInfo) extends Module
 
   // Consume TX credits and propagate pre-paid requests
   val ioX = (qX zip (tx.X zip txInc.bits.X)) map { case (q, (credit, gain)) =>
-    val first = RegEnable(q.bits.last, Bool(true), q.fire())
+    val first = RegEnable(q.bits.last, true.B, q.fire)
     val delta = credit -& q.bits.beats
-    val allow = !first || (delta.asSInt >= SInt(0))
-    credit := Mux(q.fire() && first, delta, credit) + Mux(txInc.fire(), gain, UInt(0))
+    val allow = !first || (delta.asSInt >= 0.S)
+    credit := Mux(q.fire && first, delta, credit) + Mux(txInc.fire, gain, 0.U)
 
     val cq = Module(new ShiftQueue(q.bits.cloneType, 2)) // maybe flow?
     cq.io.enq.bits := q.bits
@@ -63,24 +68,24 @@ class TX(info: ChipLinkInfo) extends Module
   // Prepare RX credit update headers
   val rxQ = Module(new ShiftQueue(new DataLayer(info.params), 2)) // maybe flow?
   val (rxHeader, rxLeft) = rx.toHeader
-  rxQ.io.enq.valid := Bool(true)
+  rxQ.io.enq.valid := true.B
   rxQ.io.enq.bits.data  := rxHeader
-  rxQ.io.enq.bits.last  := Bool(true)
-  rxQ.io.enq.bits.beats := UInt(1)
-  rx := Mux(rxQ.io.enq.fire(), rxLeft, rx) + Mux(rxInc.fire(), rxInc.bits, CreditBump(info.params, 0))
+  rxQ.io.enq.bits.last  := true.B
+  rxQ.io.enq.bits.beats := 1.U
+  rx := Mux(rxQ.io.enq.fire, rxLeft, rx) + Mux(rxInc.fire, rxInc.bits, CreditBump(info.params, 0))
 
   // Include the F credit channel in arbitration
-  val f = Wire(rxQ.io.deq)
+  val f = Wire(chiselTypeOf(rxQ.io.deq))
   val ioF = ioX :+ f
   val requests = Cat(ioF.map(_.valid).reverse)
   val lasts = Cat(ioF.map(_.bits.last).reverse)
 
   // How often should we force transmission of a credit update? sqrt
   val xmitBits = log2Ceil(info.params.Qdepth) / 2
-  val xmit = RegInit(UInt(0, width = xmitBits))
-  val forceXmit = xmit === UInt(0)
-  when (!forceXmit) { xmit := xmit - UInt(1) }
-  when (f.fire()) { xmit := ~UInt(0, width = xmitBits) }
+  val xmit = RegInit(0.U(xmitBits.W))
+  val forceXmit = xmit === 0.U
+  when (!forceXmit) { xmit := xmit - 1.U }
+  when (f.fire) { xmit := ~0.U(xmitBits.W) }
 
   // Flow control for returned credits
   val allowReturn = !ioX.map(_.valid).reduce(_ || _) || forceXmit
@@ -89,23 +94,23 @@ class TX(info: ChipLinkInfo) extends Module
   rxQ.io.deq.ready := f.ready && allowReturn
 
   // Select a channel to transmit from those with data and space
-  val first = RegInit(Bool(true))
-  val state = Reg(UInt(0, width=6))
+  val first = RegInit(true.B)
+  val state = RegInit(0.U(6.W))
   val readys = TLArbiter.roundRobin(6, requests, first)
   val winner = readys & requests
   val grant = Mux(first, winner, state)
   val allowed = Mux(first, readys, state)
   (ioF zip allowed.asBools) foreach { case (beat, sel) => beat.ready := sel }
 
-  val send = Mux(first, rxQ.io.deq.valid, (state & requests) =/= UInt(0))
-  assert (send === ((grant & requests) =/= UInt(0)))
+  val send = Mux(first, rxQ.io.deq.valid, (state & requests) =/= 0.U)
+  assert (send === ((grant & requests) =/= 0.U))
 
   when (send) { first := (grant & lasts).orR }
   when (first) { state := winner }
 
   // Form the output beat
   io.c2b_clk  := clock
-  io.c2b_rst  := AsyncResetReg(Bool(false), clock, reset, true, None)
-  io.c2b_send := RegNext(RegNext(send, Bool(false)), Bool(false))
-  io.c2b_data := RegNext(Mux1H(RegNext(grant), RegNext(Vec(ioF.map(_.bits.data)))))
+  io.c2b_rst  := AsyncResetReg(false.B, clock, reset.asBool, true, None)
+  io.c2b_send := RegNext(RegNext(send, false.B), false.B)
+  io.c2b_data := RegNext(Mux1H(RegNext(grant), RegNext(VecInit(ioF.map(_.bits.data)))))
 }
diff --git a/src/device/ChipLinkBridge.scala b/src/device/ChipLinkBridge.scala
new file mode 100644
index 00000000..14ba074f
--- /dev/null
+++ b/src/device/ChipLinkBridge.scala
@@ -0,0 +1,171 @@
+package ysyx
+
+import chisel3._
+import chisel3.util._
+
+import freechips.rocketchip.subsystem._
+import org.chipsalliance.cde.config.{Field, Parameters}
+import freechips.rocketchip.diplomacy._
+import freechips.rocketchip.tilelink._
+import freechips.rocketchip.util._
+import freechips.rocketchip.devices.tilelink._
+import freechips.rocketchip.amba.axi4._
+import freechips.rocketchip.system._
+
+import sifive.blocks.devices.chiplink._
+
+
+object ChipLinkParam {
+  // Must have a cacheable address sapce.
+  val mem  = AddressSet(0xc0000000L, 0x40000000L - 1)
+  val mmio = AddressSet(0x40000000L, 0x40000000L - 1)
+}
+
+
+class LinkTopBase(implicit p: Parameters) extends LazyModule {
+  val mbus = TLXbar()
+  val fxbar = TLXbar()
+  val ferr = LazyModule(new TLError(DevNullParams(Seq(AddressSet(0x1000L, 0x1000L - 1)), 64, 64, region = RegionType.TRACKED)))
+
+  val chiplinkParam = ChipLinkParams(
+    TLUH = List(ChipLinkParam.mmio),
+    TLC  = List(ChipLinkParam.mem),
+    syncTX = true
+  )
+
+  val chiplink = LazyModule(new ChipLink(chiplinkParam))
+  val sink = chiplink.ioNode.makeSink
+
+  chiplink.node := fxbar
+  ferr.node := fxbar
+
+  lazy val module = new LinkTopBaseImpl(this) with DontTouch {
+    chiplink.module.io.c2b_clk := clock
+    chiplink.module.io.c2b_rst := reset
+  }
+}
+
+class LinkTopBaseImpl[+L <: LinkTopBase](_outer: L) extends LazyModuleImp(_outer) {
+  val outer = _outer
+  val fpga_io = outer.sink.makeIO()
+}
+
+
+trait CanHaveAXI4MasterMemPortForLinkTop { this: LinkTopBase =>
+  private val portName = "axi4"
+  private val device = new MemoryDevice
+  private val cacheBlockBytes = 64
+  private val idBits = p(ExtMem).map(_.master.idBits).getOrElse(1)
+
+  val axi4MasterMemNode = AXI4SlaveNode(p(ExtMem).map { case MemoryPortParams(memPortParams, nMemoryChannels, _) =>
+    Seq.tabulate(nMemoryChannels) { channel =>
+      val base = ChipLinkParam.mem
+      val filter = AddressSet(channel * cacheBlockBytes, ~((nMemoryChannels-1) * cacheBlockBytes))
+
+      AXI4SlavePortParameters(
+        slaves = Seq(AXI4SlaveParameters(
+          address       = base.intersect(filter).toList,
+          resources     = device.reg,
+          regionType    = RegionType.UNCACHED, // cacheable
+          executable    = true,
+          supportsWrite = TransferSizes(1, cacheBlockBytes),
+          supportsRead  = TransferSizes(1, cacheBlockBytes),
+          interleavedId = Some(0))), // slave does not interleave read responses
+        beatBytes = memPortParams.beatBytes)
+    }
+  }.toList.flatten)
+
+  axi4MasterMemNode := AXI4UserYanker() := AXI4IdIndexer(idBits) := TLToAXI4() := mbus
+
+  val master_mem = InModuleBody { axi4MasterMemNode.makeIOs() }
+}
+
+
+/** Adds an AXI4 port to the system intended to be a slave on an MMIO device bus */
+trait CanHaveAXI4SlavePortForLinkTop { this: LinkTopBase =>
+  implicit val p: Parameters
+
+  private val slavePortParamsOpt = p(ExtIn)
+  private val portName = "slave_port_axi4_mem"
+  private val fifoBits = 1
+
+  private val idBits = 4
+  val axi4SlaveNode = AXI4MasterNode(
+    slavePortParamsOpt.map(params =>
+      AXI4MasterPortParameters(
+        masters = Seq(AXI4MasterParameters(
+          name = portName.kebab,
+          id   = IdRange(0, 1 << idBits))))).toSeq)
+
+  slavePortParamsOpt.map { params =>
+    fxbar := TLFIFOFixer(TLFIFOFixer.all) := (TLWidthWidget(params.beatBytes)
+      := AXI4ToTL()
+      := AXI4UserYanker(Some(1 << (params.sourceBits - fifoBits - 1)))
+      := AXI4Fragmenter()
+      := AXI4IdIndexer(fifoBits)
+      := axi4SlaveNode)
+  }
+
+  val slave = InModuleBody { axi4SlaveNode.makeIOs() }
+}
+
+
+/** Adds a AXI4 port to the system intended to master an MMIO device bus */
+trait CanHaveAXI4MasterMMIOPortForLinkTop { this: LinkTopBase =>
+  implicit val p: Parameters
+
+  private val mmioPortParamsOpt = p(ExtBus)
+  private val portName = "mmio_port_axi4"
+  private val device = new SimpleBus(portName.kebab, Nil)
+
+  val axi4MasterMMIONode = AXI4SlaveNode(
+    mmioPortParamsOpt.map(params =>
+      AXI4SlavePortParameters(
+        slaves = Seq(AXI4SlaveParameters(
+          address       = Seq(ChipLinkParam.mmio),
+          resources     = device.ranges,
+          executable    = params.executable,
+          supportsWrite = TransferSizes(1, params.maxXferBytes),
+          supportsRead  = TransferSizes(1, params.maxXferBytes))),
+        beatBytes = params.beatBytes)).toSeq)
+
+  mmioPortParamsOpt.map { params =>
+    axi4MasterMMIONode := (AXI4Buffer()
+      := AXI4UserYanker()
+      := AXI4Deinterleaver(64 /* blockBytes, literal OK? */)
+      := AXI4IdIndexer(params.idBits)
+      := TLToAXI4()) := mbus
+  }
+
+  val master_mmio = InModuleBody { axi4MasterMMIONode.makeIOs() }
+}
+
+
+class ChipLinkMaster(implicit p: Parameters) extends LinkTopBase
+  with CanHaveAXI4SlavePortForLinkTop
+  with CanHaveAXI4MasterMemPortForLinkTop
+{
+  // Dummy manager network
+  val err = LazyModule(new TLError(DevNullParams(Seq(AddressSet(0x1000L, 0x1000L - 1)), 64, 64, region = RegionType.TRACKED)))
+
+  // Hint & Atomic augment
+  mbus := TLAtomicAutomata(passthrough=false) := TLFIFOFixer(TLFIFOFixer.all) := TLHintHandler() := TLWidthWidget(4) := chiplink.node
+  err.node := TLWidthWidget(8) := mbus
+}
+
+
+/**
+  * Dual top module against Rocketchip over rx/tx channel.
+  */
+class ChipLinkSlave(implicit p: Parameters) extends LinkTopBase
+  with CanHaveAXI4MasterMemPortForLinkTop
+  with CanHaveAXI4MasterMMIOPortForLinkTop
+  with CanHaveAXI4SlavePortForLinkTop
+{
+  // Dummy manager network
+  val err = LazyModule(new TLError(DevNullParams(Seq(AddressSet(0x1000L, 0x1000L - 1)), 64, 64, region = RegionType.TRACKED)))
+
+  // Hint & Atomic augment
+  mbus := TLAtomicAutomata(passthrough=false) := TLFIFOFixer(TLFIFOFixer.all) := TLHintHandler() := TLWidthWidget(4) := chiplink.node
+  err.node := TLWidthWidget(8) := mbus
+}
-- 
2.34.1

