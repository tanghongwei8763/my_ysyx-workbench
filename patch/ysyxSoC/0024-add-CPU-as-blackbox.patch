From dc1c5eeb8a56adee009d8979113dcc135ced0589 Mon Sep 17 00:00:00 2001
From: Zihao Yu <yuzihao@ict.ac.cn>
Date: Wed, 1 Sep 2021 10:21:05 +0800
Subject: [PATCH 24/74] add CPU as blackbox

---
 src/CPU.scala                   | 45 ++++++++++++++++++++++++++++
 src/SoC.scala                   | 53 ++++++++++-----------------------
 src/Top.scala                   |  3 --
 src/device/ChipLinkBridge.scala |  8 ++---
 4 files changed, 64 insertions(+), 45 deletions(-)
 create mode 100644 src/CPU.scala

diff --git a/src/CPU.scala b/src/CPU.scala
new file mode 100644
index 00000000..aaa8fac2
--- /dev/null
+++ b/src/CPU.scala
@@ -0,0 +1,45 @@
+package ysyx
+
+import chisel3._
+import chisel3.util._
+
+import org.chipsalliance.cde.config.Parameters
+import freechips.rocketchip.subsystem._
+import freechips.rocketchip.amba.axi4._
+import freechips.rocketchip.diplomacy._
+import freechips.rocketchip.util._
+
+object CPUAXI4BundleParameters {
+  def apply() = AXI4BundleParameters(addrBits = 32, dataBits = 64, idBits = ChipLinkParam.idBits)
+}
+
+class ysyx_00000000 extends BlackBox {
+  val io = IO(new Bundle {
+    val clock = Input(Clock())
+    val reset = Input(Reset())
+    val interrupt = Input(Bool())
+    val io_master = AXI4Bundle(CPUAXI4BundleParameters())
+    val io_slave = Flipped(AXI4Bundle(CPUAXI4BundleParameters()))
+  })
+}
+
+class CPU(idBits: Int)(implicit p: Parameters) extends LazyModule {
+  val masterNode = AXI4MasterNode(p(ExtIn).map(params =>
+    AXI4MasterPortParameters(
+      masters = Seq(AXI4MasterParameters(
+        name = "cpu",
+        id   = IdRange(0, 1 << idBits))))).toSeq)
+  lazy val module = new Impl
+  class Impl extends LazyModuleImp(this) {
+    val (master, _) = masterNode.out(0)
+    val interrupt = IO(Input(Bool()))
+    val slave = IO(Flipped(AXI4Bundle(CPUAXI4BundleParameters())))
+
+    val cpu = Module(new ysyx_00000000)
+    cpu.io.clock := clock
+    cpu.io.reset := reset
+    cpu.io.interrupt := interrupt
+    cpu.io.io_slave <> slave
+    master <> cpu.io.io_master
+  }
+}
diff --git a/src/SoC.scala b/src/SoC.scala
index 57eb3269..3222485e 100644
--- a/src/SoC.scala
+++ b/src/SoC.scala
@@ -24,18 +24,10 @@ object AXI4SlaveNodeGenerator {
 }
 
 class ysyxSoCASIC(implicit p: Parameters) extends LazyModule {
-  val idBits = 4
-
   val chipMaster = LazyModule(new ChipLinkMaster)
   val xbar = AXI4Xbar()
   val apbxbar = LazyModule(new APBFanout).node
-
-  val cpuMasterNode = AXI4MasterNode(p(ExtIn).map(params =>
-    AXI4MasterPortParameters(
-      masters = Seq(AXI4MasterParameters(
-        name = "cpu",
-        id   = IdRange(0, 1 << idBits))))).toSeq)
-
+  val cpu = LazyModule(new CPU(idBits = ChipLinkParam.idBits))
   val chiplinkNode = AXI4SlaveNodeGenerator(p(ExtBus), ChipLinkParam.allSpace)
 
   val luart = LazyModule(new APBUart16550(AddressSet.misaligned(0x10000000, 0x1000)))
@@ -46,40 +38,33 @@ class ysyxSoCASIC(implicit p: Parameters) extends LazyModule {
 
   List(lspi.node, luart.node).map(_ := apbxbar)
   List(chiplinkNode, apbxbar := AXI4ToAPB()).map(_ := xbar)
-  xbar := cpuMasterNode
+  xbar := cpu.masterNode
 
   override lazy val module = new Impl
   class Impl extends LazyModuleImp(this) with DontTouch {
     // generate delayed reset for cpu, since chiplink should finish reset
     // to initialize some async modules before accept any requests from cpu
-    val cpu_reset = IO(Flipped(chiselTypeOf(reset)))
-    cpu_reset := SynchronizerShiftReg(reset.asBool, 10) || reset.asBool
+    cpu.module.reset := SynchronizerShiftReg(reset.asBool, 10) || reset.asBool
+
+    // connect chiplink slave interface to crossbar
+    (chipMaster.slave zip chiplinkNode.in) foreach { case (io, (bundle, _)) => io <> bundle }
+
+    // connect chiplink dma interface to cpu
+    cpu.module.slave <> chipMaster.master_mem(0)
 
-    // expose cpu master interface as ports
-    val cpu_master  = IO(Flipped(HeterogeneousBag.fromNode(cpuMasterNode.out)))
-    (cpuMasterNode.out  zip cpu_master ) foreach { case ((bundle, _), io) => bundle <> io }
+    // connect interrupt signal to cpu
+    val intr_from_chipSlave = IO(Input(Bool()))
+    cpu.module.interrupt := intr_from_chipSlave
 
     // expose chiplink fpga I/O interface as ports
     val fpga_io = IO(chiselTypeOf(chipMaster.module.fpga_io))
     fpga_io <> chipMaster.module.fpga_io
 
-    // connect chiplink slave interface to crossbar
-    (chipMaster.slave zip chiplinkNode.in) foreach { case (io, (bundle, _)) => io <> bundle }
-
-    // expose chiplink dma interface as ports
-    val chiplink_dma = chipMaster.master_mem(0)
-    val cpu_slave = IO(chiselTypeOf(chiplink_dma))
-    cpu_slave <> chiplink_dma
-
     // expose spi and uart slave interface as ports
     val spi = IO(chiselTypeOf(lspi.module.spi_bundle))
     val uart = IO(chiselTypeOf(luart.module.uart))
     uart <> luart.module.uart
     spi <> lspi.module.spi_bundle
-
-    val intr_to_cpu = IO(Output(Bool()))
-    val intr_from_chipSlave = IO(Input(Bool()))
-    intr_to_cpu := intr_from_chipSlave
   }
 }
 
@@ -92,6 +77,7 @@ class ysyxSoCFull(implicit p: Parameters) extends LazyModule {
   override lazy val module = new Impl
   class Impl extends LazyModuleImp(this) with DontTouch {
     val masic = asic.module
+    masic.dontTouchPorts()
     val fpga = LazyModule(new ysyxSoCFPGA)
     val mfpga = Module(fpga.module)
 
@@ -108,20 +94,11 @@ class ysyxSoCFull(implicit p: Parameters) extends LazyModule {
     fpga.master_mmio.map(_ := DontCare)
     fpga.slave.map(_ := DontCare)
 
-    val cpu_reset  = IO(chiselTypeOf(masic.cpu_reset))
-    val cpu_intr   = IO(Output(Bool()))
-    val cpu_master = IO(chiselTypeOf(masic.cpu_master))
-    val cpu_slave  = IO(chiselTypeOf(masic.cpu_slave))
-    cpu_reset := masic.cpu_reset
-    masic.cpu_master <> cpu_master
-    cpu_slave <> masic.cpu_slave
-    cpu_intr := masic.intr_to_cpu
-    masic.intr_from_chipSlave := false.B //mfpga.intr_to_chipMaster
+    masic.intr_from_chipSlave := false.B
 
     val flash = Module(new flash)
-    val uart = IO(chiselTypeOf(masic.uart))
     flash.io <> masic.spi
     flash.io.ss := masic.spi.ss(0)
-    uart <> masic.uart
+    masic.uart.rx := false.B
   }
 }
diff --git a/src/Top.scala b/src/Top.scala
index 98978fc9..0d334485 100644
--- a/src/Top.scala
+++ b/src/Top.scala
@@ -12,9 +12,6 @@ class ysyxSoCTop extends Module {
   val dut = LazyModule(new ysyxSoCFull)
   val mdut = Module(dut.module)
   mdut.dontTouchPorts()
-  mdut.cpu_master := DontCare
-  mdut.cpu_slave := DontCare
-  mdut.uart.rx := true.B
 }
 
 object Elaborate extends App {
diff --git a/src/device/ChipLinkBridge.scala b/src/device/ChipLinkBridge.scala
index 5b8e0ce5..7ce54389 100644
--- a/src/device/ChipLinkBridge.scala
+++ b/src/device/ChipLinkBridge.scala
@@ -19,8 +19,8 @@ object ChipLinkParam {
   // Must have a cacheable address sapce.
   val mem  = AddressSet(0xc0000000L, 0x40000000L - 1)
   val mmio = AddressSet(0x40000000L, 0x40000000L - 1)
-
   val allSpace = Seq(mem, mmio)
+  val idBits = 4
 }
 
 
@@ -57,7 +57,7 @@ trait CanHaveAXI4MasterMemPortForLinkTop { this: LinkTopBase =>
   private val portName = "axi4"
   private val device = new MemoryDevice
   private val cacheBlockBytes = 64
-  private val idBits = p(ExtMem).map(_.master.idBits).getOrElse(1)
+  private val idBits = ChipLinkParam.idBits
 
   val axi4MasterMemNode = AXI4SlaveNode(p(ExtMem).map { case MemoryPortParams(memPortParams, nMemoryChannels, _) =>
     Seq.tabulate(nMemoryChannels) { channel =>
@@ -90,8 +90,8 @@ trait CanHaveAXI4SlavePortForLinkTop { this: LinkTopBase =>
   private val slavePortParamsOpt = p(ExtIn)
   private val portName = "slave_port_axi4_mem"
   private val fifoBits = 1
+  private val idBits = ChipLinkParam.idBits
 
-  private val idBits = 4
   val axi4SlaveNode = AXI4MasterNode(
     slavePortParamsOpt.map(params =>
       AXI4MasterPortParameters(
@@ -135,7 +135,7 @@ trait CanHaveAXI4MasterMMIOPortForLinkTop { this: LinkTopBase =>
     axi4MasterMMIONode := (AXI4Buffer()
       := AXI4UserYanker()
       := AXI4Deinterleaver(64 /* blockBytes, literal OK? */)
-      := AXI4IdIndexer(params.idBits)
+      := AXI4IdIndexer(ChipLinkParam.idBits)
       := TLToAXI4()) := mbus
   }
 
-- 
2.34.1

