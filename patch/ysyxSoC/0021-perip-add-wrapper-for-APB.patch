From e0d28ef51eeaf3d1820207c14321d42d95b4d55a Mon Sep 17 00:00:00 2001
From: Zihao Yu <yuzihao@ict.ac.cn>
Date: Mon, 18 Dec 2023 18:06:51 +0800
Subject: [PATCH 21/74] perip: add wrapper for APB

---
 perip/flash/flash.v                |  2 +-
 perip/spi/rtl/spi_top_apb.v        | 49 ++++++++++++++++
 perip/uart16550/rtl/uart_top_apb.v | 92 ++++++++++++++++++++++++++++++
 src/SoC.scala                      |  4 +-
 src/device/SPI.scala               |  6 +-
 src/device/Uart16550.scala         |  4 +-
 6 files changed, 149 insertions(+), 8 deletions(-)
 create mode 100644 perip/spi/rtl/spi_top_apb.v
 create mode 100644 perip/uart16550/rtl/uart_top_apb.v

diff --git a/perip/flash/flash.v b/perip/flash/flash.v
index d2d29a52..2ef4158c 100644
--- a/perip/flash/flash.v
+++ b/perip/flash/flash.v
@@ -5,7 +5,7 @@
 
 `define spi_cs_num 2
 
-module spiFlash (
+module flash (
   input                    clk,
   input  [`spi_cs_num-1:0] cs,
   input                    mosi,
diff --git a/perip/spi/rtl/spi_top_apb.v b/perip/spi/rtl/spi_top_apb.v
new file mode 100644
index 00000000..217a4897
--- /dev/null
+++ b/perip/spi/rtl/spi_top_apb.v
@@ -0,0 +1,49 @@
+module spi_top_apb #(
+  parameter flash_addr_start = 32'h30000000,
+  parameter flash_addr_end   = 32'h3fffffff,
+  parameter spi_cs_num       = 2
+) (
+  input         clk,
+  input         resetn,
+  input  [31:0] in_paddr,
+  input         in_psel,
+  input         in_penable,
+  input  [2:0]  in_pprot,
+  input         in_pwrite,
+  input  [31:0] in_pwdata,
+  input  [3:0]  in_pstrb,
+  output        in_pready,
+  output [31:0] in_prdata,
+  output        in_pslverr,
+
+  output                  spi_clk,
+  output [spi_cs_num-1:0] spi_cs,
+  output                  spi_mosi,
+  input                   spi_miso,
+  output                  spi_irq_out
+);
+
+wire [7:0] ss_pad_o;
+assign spi_cs = ss_pad_o[spi_cs_num-1:0];
+
+spi_top u0_spi_top (
+  .wb_clk_i(clk),
+  .wb_rst_i(!resetn),
+  .wb_adr_i(in_paddr[4:0]),
+  .wb_dat_i(in_pwdata),
+  .wb_dat_o(in_prdata),
+  .wb_sel_i(in_pstrb),
+  .wb_we_i (in_pwrite),
+  .wb_stb_i(in_psel),
+  .wb_cyc_i(in_penable),
+  .wb_ack_o(in_pready),
+  .wb_err_o(in_pslverr),
+  .wb_int_o(),
+
+  .ss_pad_o(ss_pad_o),
+  .sclk_pad_o(spi_clk),
+  .mosi_pad_o(spi_mosi),
+  .miso_pad_i(spi_miso)
+);
+
+endmodule
diff --git a/perip/uart16550/rtl/uart_top_apb.v b/perip/uart16550/rtl/uart_top_apb.v
new file mode 100644
index 00000000..93f613cc
--- /dev/null
+++ b/perip/uart16550/rtl/uart_top_apb.v
@@ -0,0 +1,92 @@
+module uart_top_apb (
+       input   wire        resetn
+     , input   wire        clk
+     , input   wire        in_psel
+     , input   wire        in_penable
+     , input   wire [2:0]   in_pprot
+     , output              in_pready
+     , output  wire        in_pslverr
+     , input   wire [31:0] in_paddr
+     , input   wire        in_pwrite
+     , output  wire [31:0] in_prdata
+     , input   wire [31:0] in_pwdata
+     , input   wire [3:0]  in_pstrb
+     , input   wire        uart_rx       // serial output
+     , output  wire        uart_tx       // serial input
+);
+   //--------------------------------------------------
+   wire   rtsn;
+   wire   ctsn = 1'b0;
+   wire   dtr_pad_o;
+   wire   dsr_pad_i=1'b0;
+   wire   ri_pad_i =1'b0;
+   wire   dcd_pad_i=1'b0;
+   wire   interrupt;
+   //--------------------------------------------------------
+   wire       reg_we;   // Write enable for registers
+   wire       reg_re;   // Read enable for registers
+   wire [2:0] reg_adr;
+   reg  [7:0] reg_dat8_w; // write to reg
+   reg  [7:0] reg_dat8_w_reg;
+   wire [7:0] reg_dat8_r; // read from reg
+   wire       rts_internal;
+   assign     rtsn = ~rts_internal;
+   //--------------------------------------------------------
+   assign in_pready = in_psel && in_penable;
+   assign in_pslverr = 1'b0;
+   //assign reg_we  = resetn & in_psel & ~in_penable &  in_pwrite;
+   assign reg_we  = resetn & in_psel & in_penable &  in_pwrite;
+   assign reg_re  = resetn & in_psel & in_penable & ~in_pwrite;
+   assign reg_adr = in_paddr[2:0]; //assign adr_o   = in_paddr[2:0];
+   assign in_prdata  = (in_psel) ? {4{reg_dat8_r}} : 'h0;
+   always @ (in_paddr[1:0] or in_pwdata) begin
+             case (in_paddr[1:0])
+             `ifdef ENDIAN_BIG
+             2'b00: reg_dat8_w = #1 in_pwdata[31:24];
+             2'b01: reg_dat8_w = #1 in_pwdata[23:16];
+             2'b10: reg_dat8_w = #1 in_pwdata[15:8];
+             2'b11: reg_dat8_w = #1 in_pwdata[7:0];
+             `else // little-endian -- default
+             2'b00: reg_dat8_w = #1 in_pwdata[7:0];
+             2'b01: reg_dat8_w = #1 in_pwdata[15:8];
+             2'b10: reg_dat8_w = #1 in_pwdata[23:16];
+             2'b11: reg_dat8_w = #1 in_pwdata[31:24];
+             `endif
+             endcase
+   end
+   always @ (posedge clk) begin
+     reg_dat8_w_reg <= reg_dat8_w;
+   end
+   //--------------------------------------------------------
+   // Registers
+   // As shown below reg_dat_i should be stable
+   // one-cycle after reg_we negates.
+   //              ___     ___     ___     ___     ___     ___
+   //  clk      __|   |___|   |___|   |___|   |___|   |___|   |__
+   //             ________________        ________________
+   //  reg_adr  XX________________XXXXXXXX________________XXXX
+   //             ________________
+   //  reg_dat_i X________________XXXXXXX
+   //                                     ________________
+   //  reg_dat_o XXXXXXXXXXXXXXXXXXXXXXXXX________________XXXX
+   //                                              _______
+   //  reg_re   __________________________________|       |_____
+   //              _______
+   //  reg_we   __|       |_____________________________________
+   //
+   uart_regs Uregs(
+          .clk         (clk),
+          .wb_rst_i    (~resetn),
+          .wb_addr_i   (reg_adr),
+          .wb_dat_i    (in_pwrite ? reg_dat8_w:reg_dat8_w_reg),
+          .wb_dat_o    (reg_dat8_r),
+          .wb_we_i     (reg_we),
+          .wb_re_i     (reg_re),
+          .modem_inputs({~ctsn, dsr_pad_i, ri_pad_i,  dcd_pad_i}),
+          .stx_pad_o   (uart_tx),
+          .srx_pad_i   (uart_rx),
+          .rts_pad_o   (rts_internal),
+          .dtr_pad_o   (dtr_pad_o),
+          .int_o       (interrupt)
+   );
+endmodule
diff --git a/src/SoC.scala b/src/SoC.scala
index 9dc4e726..797e953e 100644
--- a/src/SoC.scala
+++ b/src/SoC.scala
@@ -118,9 +118,9 @@ class ysyxSoCFull(implicit p: Parameters) extends LazyModule {
     cpu_intr := masic.intr_to_cpu
     masic.intr_from_chipSlave := false.B //mfpga.intr_to_chipMaster
 
-    val spiFlash = Module(new spiFlash)
+    val flash = Module(new flash)
     val uart = IO(chiselTypeOf(masic.uart))
-    spiFlash.io <> masic.spi
+    flash.io <> masic.spi
     uart <> masic.uart
   }
 }
diff --git a/src/device/SPI.scala b/src/device/SPI.scala
index e4958d51..f1a65acd 100644
--- a/src/device/SPI.scala
+++ b/src/device/SPI.scala
@@ -15,7 +15,7 @@ class SPIIO(val csWidth: Int = 2) extends Bundle {
   val miso = Input(Bool())
 }
 
-class spi extends BlackBox {
+class spi_top_apb extends BlackBox {
   val io = IO(new Bundle {
     val clk = Input(Clock())
     val resetn = Input(Bool())
@@ -25,7 +25,7 @@ class spi extends BlackBox {
   })
 }
 
-class spiFlash extends BlackBox {
+class flash extends BlackBox {
   val io = IO(Flipped(new SPIIO))
 }
 
@@ -43,7 +43,7 @@ class APBSPI(address: Seq[AddressSet])(implicit p: Parameters) extends LazyModul
     val (in, _) = node.in(0)
     val spi_bundle = IO(new SPIIO)
 
-    val mspi = Module(new spi)
+    val mspi = Module(new spi_top_apb)
     mspi.io.clk := clock
     mspi.io.resetn := ~reset.asBool
     mspi.io.in <> in
diff --git a/src/device/Uart16550.scala b/src/device/Uart16550.scala
index afb5c773..e9ef33aa 100644
--- a/src/device/Uart16550.scala
+++ b/src/device/Uart16550.scala
@@ -13,7 +13,7 @@ class UARTIO extends Bundle {
   val tx = Output(Bool())
 }
 
-class uart_apb extends BlackBox {
+class uart_top_apb extends BlackBox {
   val io = IO(new Bundle {
     val clk = Input(Clock())
     val resetn = Input(Bool())
@@ -36,7 +36,7 @@ class APBUart16550(address: Seq[AddressSet])(implicit p: Parameters) extends Laz
     val (in, _) = node.in(0)
     val uart = IO(new UARTIO)
 
-    val muart = Module(new uart_apb)
+    val muart = Module(new uart_top_apb)
     muart.io.clk := clock
     muart.io.resetn := ~reset.asBool
     muart.io.in <> in
-- 
2.34.1

